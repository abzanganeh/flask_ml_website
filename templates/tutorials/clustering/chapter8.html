<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 8: Hierarchical Clustering - Comprehensive Clustering Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/tutorials/clustering/clustering.css') }}">
    <script src="{{ url_for('static', filename='js/tutorials/clustering/shared-tutorial.js') }}"></script>
    <script src="{{ url_for('static', filename='js/tutorials/clustering/chapter4.js') }}"></script>
</head>
<body>
    <header class="azbn-header">
        <nav class="azbn-nav">
            <div class="azbn-container">
                <a href="/tutorials/clustering" class="course-link">
                    <span>Comprehensive Clustering Analysis</span>
                </a>
                <div class="azbn-links">
                    <a href="/">Home</a>
                    <a href="/#about">About</a>
                    <a href="/tutorials/">Tutorials</a>
                    <a href="/#projects">Projects</a>
                    <a href="/contact">Contact</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        <!-- Tutorial Header -->
        <div class="tutorial-header">
            <div class="azbn-container">
                <h1 class="chapter-title">Chapter 4: K-means Clustering Algorithm</h1>
                <p class="chapter-subtitle">Master the most popular clustering algorithm from mathematical foundations to practical implementation</p>
                
                <!-- Chapter Progress Bar (4/15) -->
                <div class="chapter-progress">
                    <div class="chapter-progress-fill" data-progress="26.67"></div>
                </div>
                
                <!-- Chapter Navigation (All 15 chapters) -->
                <div class="chapter-navigation">
                    <a href="/tutorials/clustering/chapter1" class="chapter-nav-btn">Chapter 1</a>
                    <a href="/tutorials/clustering/chapter2" class="chapter-nav-btn">Chapter 2</a>
                    <a href="/tutorials/clustering/chapter3" class="chapter-nav-btn">Chapter 3</a>
                    <a href="/tutorials/clustering/chapter4" class="chapter-nav-btn">Chapter 4</a>
                    <a href="/tutorials/clustering/chapter5" class="chapter-nav-btn">Chapter 5</a>
                    <a href="/tutorials/clustering/chapter6" class="chapter-nav-btn">Chapter 6</a>
                    <a href="/tutorials/clustering/chapter7" class="chapter-nav-btn">Chapter 7</a>
                    <a href="/tutorials/clustering/chapter8" class="chapter-nav-btn active">Chapter 8</a>
                    <a href="/tutorials/clustering/chapter9" class="chapter-nav-btn">Chapter 9</a>
                    <a href="/tutorials/clustering/chapter10" class="chapter-nav-btn">Chapter 10</a>
                    <a href="/tutorials/clustering/chapter11" class="chapter-nav-btn">Chapter 11</a>
                    <a href="/tutorials/clustering/chapter12" class="chapter-nav-btn">Chapter 12</a>
                    <a href="/tutorials/clustering/chapter13" class="chapter-nav-btn">Chapter 13</a>
                    <a href="/tutorials/clustering/chapter14" class="chapter-nav-btn">Chapter 14</a>
                    <a href="/tutorials/clustering/chapter15" class="chapter-nav-btn">Chapter 15</a>
                </div>
                
                <!-- Section Progress Bar -->
                <div class="section-progress">
                    <div class="section-progress-fill" data-progress="14.29"></div>
                </div>
                
                <!-- Section Navigation -->
                <div class="section-nav">
                    <button class="section-nav-btn active" data-section="algorithm">Algorithm Overview</button>
                    <button class="section-nav-btn" data-section="mathematics">Mathematical Foundation</button>
                    <button class="section-nav-btn" data-section="initialization">Initialization Methods</button>
                    <button class="section-nav-btn" data-section="optimization">Optimization Process</button>
                    <button class="section-nav-btn" data-section="convergence">Convergence Analysis</button>
                    <button class="section-nav-btn" data-section="demo">Interactive Demo</button>
                    <button class="section-nav-btn" data-section="quiz">Quiz</button>
                </div>
            </div>
        </div>

        <section class="azbn-section">
            <div class="azbn-container">
                <!-- Learning Objectives -->
                <div class="learning-objectives-box">
                    <h2>Learning Objectives</h2>
                    <ul>
                        <li>Understand the K-means algorithm step-by-step process</li>
                        <li>Master the mathematical foundations and objective function</li>
                        <li>Learn different initialization methods and their impact</li>
                        <li>Analyze convergence properties and stopping criteria</li>
                        <li>Implement K-means from scratch with interactive demos</li>
                        <li>Compare different distance metrics in K-means clustering</li>
                        <li>Evaluate clustering quality using various metrics</li>
                    </ul>
                </div>

                <!-- Main Content Area -->
                <main class="chapter-main-content">
                    <!-- Algorithm Overview Section -->
                    <div id="algorithm" class="content-section active">
                        <h2>Hierarchical Clustering: Revealing Nested Structure in Data</h2>
                        
                        <p>Hierarchical clustering represents a fundamentally different approach to clustering compared to partitional methods like K-means. Instead of producing a single flat partitioning, hierarchical methods construct a tree-like hierarchy of clusters, revealing structure at multiple scales simultaneously. This approach is particularly valuable when the natural granularity of clustering is unknown or when understanding relationships between clusters is important.</p>

                        <h3>Core Concepts and Motivation</h3>
                        <p>Hierarchical clustering addresses several limitations of flat clustering methods by providing a multi-resolution view of data structure.</p>

                        <div class="unsupervised-types-grid">
                            <div class="type-card">
                                <h4>Advantages of Hierarchical Approach</h4>
                                <ul>
                                    <li><strong>No k specification:</strong> Don't need to choose number of clusters a priori</li>
                                    <li><strong>Multi-scale structure:</strong> Reveals clustering at different resolutions</li>
                                    <li><strong>Deterministic results:</strong> Given distance matrix, results are reproducible</li>
                                    <li><strong>Natural interpretation:</strong> Tree structure is intuitive to understand</li>
                                    <li><strong>Nested clusters:</strong> Shows relationships between cluster groupings</li>
                                </ul>
                            </div>
                            
                            <div class="type-card">
                                <h4>Types of Hierarchical Structure</h4>
                                <ul>
                                    <li><strong>Agglomerative:</strong> Bottom-up approach, merge similar clusters</li>
                                    <li><strong>Divisive:</strong> Top-down approach, split heterogeneous clusters</li>
                                    <li><strong>Nested partitions:</strong> Each level gives valid clustering</li>
                                    <li><strong>Binary trees:</strong> Most common structure with binary merges/splits</li>
                                    <li><strong>Ultrametric trees:</strong> Special case with meaningful distances</li>
                                </ul>
                            </div>
                            
                            <div class="type-card">
                                <h4>Key Applications</h4>
                                <ul>
                                    <li><strong>Phylogenetic analysis:</strong> Evolutionary relationships in biology</li>
                                    <li><strong>Taxonomy construction:</strong> Scientific classification systems</li>
                                    <li><strong>Social network analysis:</strong> Community structure at multiple scales</li>
                                    <li><strong>Market segmentation:</strong> Customer hierarchy and sub-segments</li>
                                    <li><strong>Gene expression analysis:</strong> Co-expression patterns and pathways</li>
                                </ul>
                            </div>
                        </div>

                        <h3>Mathematical Framework</h3>
                        <p>Hierarchical clustering can be formalized through mathematical structures that capture the nested nature of cluster relationships.</p>

                        <div class="model-box">
                            <h4>Mathematical Foundations</h4>
                            
                            <h5>Hierarchical Clustering Definition:</h5>
                            <div class="formula-box">
                                <p>A hierarchical clustering of a set X = {x₁, x₂, ..., xₙ} is a sequence of partitions:</p>
                                <div class="formula-display">
                                    <strong>P₀, P₁, P₂, ..., Pₙ₋₁</strong>
                                </div>
                                <p>Where:</p>
                                <ul>
                                    <li><strong>P₀ = {{x₁}, {x₂}, ..., {xₙ}}:</strong> Each point is its own cluster</li>
                                    <li><strong>Pₙ₋₁ = {X}:</strong> All points in single cluster</li>
                                    <li><strong>Nested property:</strong> Each partition is a refinement of the next</li>
                                </ul>
                            </div>
                            
                            <h5>Dendrogram Representation:</h5>
                            <div class="formula-box">
                                <p>A dendrogram is a binary tree T where:</p>
                                <ul>
                                    <li><strong>Leaves:</strong> Correspond to individual data points</li>
                                    <li><strong>Internal nodes:</strong> Represent cluster merges (agglomerative) or splits (divisive)</li>
                                    <li><strong>Heights:</strong> Encode dissimilarity at which merges/splits occur</li>
                                    <li><strong>Cuts:</strong> Horizontal cuts through tree give different clusterings</li>
                                </ul>
                            </div>
                            
                            <h5>Ultrametric Property:</h5>
                            <div class="formula-box">
                                <p>For hierarchical clustering to be consistent, the distance function should satisfy:</p>
                                <div class="formula-display">
                                    <strong>d(x, z) ≤ max{d(x, y), d(y, z)}</strong>
                                </div>
                                <p>This ultrametric inequality is stronger than the triangle inequality and ensures hierarchical consistency.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Mathematical Foundation Section -->
                    <div id="mathematics" class="content-section">
                        <h2>Initialization Methods: Setting the Stage for Success</h2>
                        
                        <p>The initialization phase of K-means clustering is critical for achieving high-quality results. Poor initialization can lead to suboptimal local minima, slow convergence, and inconsistent results across runs. This section explores various initialization strategies, from simple random selection to sophisticated heuristics.</p>

                        <h3>Random Initialization: The Baseline</h3>
                        <p>The simplest approach randomly selects k data points as initial centroids, but this method has significant limitations.</p>

                        <div class="model-box">
                            <h4>Random Initialization Algorithm</h4>
                            
                            <div class="formula-box">
                                <h5><strong>Basic Random Selection:</strong></h5>
                                <div class="code-box">
<strong>function</strong> random_init(X, k):
    n, d = X.shape
    indices = random_sample(n, k)  <span style="color: #1976d2;">// Sample k indices without replacement</span>
    centroids = X[indices]          <span style="color: #1976d2;">// Select corresponding data points</span>
    <strong>return</strong> centroids
                                </div>
                                
                                <h5><strong>Random Uniform in Feature Space:</strong></h5>
                                <div class="code-box">
<strong>function</strong> random_uniform_init(X, k):
    n, d = X.shape
    min_vals = min(X, axis=0)       <span style="color: #1976d2;">// Feature-wise minimum</span>
    max_vals = max(X, axis=0)       <span style="color: #1976d2;">// Feature-wise maximum</span>
    centroids = uniform(min_vals, max_vals, size=(k, d))
    <strong>return</strong> centroids
                                </div>
                            </div>
                            
                            <h5>Advantages of Random Initialization:</h5>
                            <ul>
                                <li><strong>Simplicity:</strong> Easy to implement and understand</li>
                                <li><strong>Speed:</strong> O(kd) time complexity</li>
                                <li><strong>Unbiased:</strong> No assumptions about data structure</li>
                                <li><strong>Baseline:</strong> Good reference for comparing other methods</li>
                            </ul>
                            
                            <h5>Disadvantages:</h5>
                            <ul>
                                <li><strong>High variance:</strong> Results vary significantly across runs</li>
                                <li><strong>Poor clustering:</strong> Often leads to suboptimal solutions</li>
                                <li><strong>Slow convergence:</strong> May require many iterations</li>
                                <li><strong>Empty clusters:</strong> Risk of centroids in sparse regions</li>
                            </ul>
                        </div>

                        <h3>Furthest-First Heuristic</h3>
                        <p>This method iteratively selects centroids that are as far as possible from previously selected ones, promoting good coverage of the data space.</p>

                        <div class="model-box">
                            <h4>Furthest-First Initialization</h4>
                            
                            <div class="formula-box">
                                <div class="code-box">
<strong>function</strong> furthest_first_init(X, k):
    n, d = X.shape
    centroids = []
    
    <span style="color: #1976d2;">// Step 1: Choose first centroid randomly</span>
    first_idx = random_choice(n)
    centroids.append(X[first_idx])
    
    <span style="color: #1976d2;">// Step 2: Iteratively choose furthest points</span>
    <strong>for</strong> i = 2 <strong>to</strong> k:
        max_distance = -1
        furthest_idx = -1
        
        <strong>for</strong> j = 1 <strong>to</strong> n:
            <span style="color: #1976d2;">// Find minimum distance to existing centroids</span>
            min_dist = min([distance(X[j], c) <strong>for</strong> c <strong>in</strong> centroids])
            
            <strong>if</strong> min_dist > max_distance:
                max_distance = min_dist
                furthest_idx = j
        
        centroids.append(X[furthest_idx])
    
    <strong>return</strong> centroids
                                </div>
                            </div>
                            
                            <h5>Advantages:</h5>
                            <ul>
                                <li><strong>Good coverage:</strong> Centroids spread across data space</li>
                                <li><strong>Deterministic:</strong> Same result for same first choice</li>
                                <li><strong>No empty clusters:</strong> Guarantees centroids on data points</li>
                                <li><strong>Better than random:</strong> Generally produces better initializations</li>
                            </ul>
                            
                            <h5>Disadvantages:</h5>
                            <ul>
                                <li><strong>Outlier sensitivity:</strong> May select extreme outliers</li>
                                <li><strong>Computational cost:</strong> O(nk) time complexity</li>
                                <li><strong>Still suboptimal:</strong> Not guaranteed to find good initializations</li>
                                <li><strong>First choice matters:</strong> Quality depends on initial random selection</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Initialization Methods Section -->
                    <div id="initialization" class="content-section">
                        <h2>K-means++: The Smart Initialization Revolution</h2>
                        
                        <p>K-means++ represents a breakthrough in K-means initialization, providing both theoretical guarantees and practical improvements. Developed by Arthur and Vassilvitskii in 2007, this method uses probabilistic selection to choose initial centroids that are likely to be well-separated, leading to better clustering results.</p>

                        <h3>The K-means++ Algorithm</h3>
                        <p>K-means++ carefully selects initial centroids using a probability distribution that favors points far from existing centroids.</p>

                        <div class="model-box">
                            <h4>K-means++ Initialization Algorithm</h4>
                            
                            <div class="formula-box">
                                <div class="code-box">
<strong>function</strong> kmeans_plus_plus(X, k):
    n, d = X.shape
    centroids = []
    
    <span style="color: #1976d2;">// Step 1: Choose first centroid uniformly at random</span>
    first_idx = random_choice(n)
    centroids.append(X[first_idx])
    
    <span style="color: #1976d2;">// Step 2: Choose remaining k-1 centroids</span>
    <strong>for</strong> i = 2 <strong>to</strong> k:
        distances = []
        
        <span style="color: #1976d2;">// Compute squared distance to nearest existing centroid</span>
        <strong>for</strong> j = 1 <strong>to</strong> n:
            min_dist_sq = min([||X[j] - c||² <strong>for</strong> c <strong>in</strong> centroids])
            distances.append(min_dist_sq)
        
        <span style="color: #1976d2;">// Choose next centroid with probability proportional to squared distance</span>
        probabilities = distances / sum(distances)
        next_idx = weighted_random_choice(probabilities)
        centroids.append(X[next_idx])
    
    <strong>return</strong> centroids
                                </div>
                            </div>
                            
                            <h5>Key Insight:</h5>
                            <p>The probability of selecting a point as the next centroid is proportional to its squared distance from the nearest existing centroid. This creates a bias toward points that are far from current centroids, promoting good spatial distribution.</p>
                            
                            <h5>Mathematical Formulation:</h5>
                            <div class="formula-box">
                                <p>For selecting the (j+1)-th centroid, given j existing centroids C = {c₁, c₂, ..., cⱼ}:</p>
                                <div class="formula-display">
                                    <strong>P(xᵢ) = D²(xᵢ) / Σₖ D²(xₖ)</strong>
                                </div>
                                <p>Where D²(xᵢ) = min_{c∈C} ||xᵢ - c||² is the squared distance to the nearest centroid.</p>
                            </div>
                        </div>

                        <h3>Theoretical Analysis</h3>
                        <p>K-means++ comes with strong theoretical guarantees that explain its superior performance.</p>

                        <div class="model-box">
                            <h4>K-means++ Approximation Guarantee</h4>
                            
                            <h5>Main Theorem (Arthur & Vassilvitskii, 2007):</h5>
                            <div class="formula-box">
                                <p><strong>Theorem:</strong> K-means++ initialization followed by Lloyd's algorithm produces a solution with expected cost at most O(log k) times the optimal k-means cost.</p>
                                
                                <p><strong>Formally:</strong> E[cost(K-means++ solution)] ≤ 8(ln k + 2) × OPT</p>
                                
                                <p>Where OPT is the cost of the optimal k-means clustering.</p>
                            </div>
                            
                            <h5>Proof Sketch:</h5>
                            <ol>
                                <li><strong>Potential function:</strong> Define Φ = Σᵢ D²(xᵢ) as sum of squared distances to nearest centroids</li>
                                <li><strong>Expected reduction:</strong> Each K-means++ step reduces E[Φ] by a constant factor</li>
                                <li><strong>Concentration:</strong> Use probability tail bounds to show consistent performance</li>
                                <li><strong>Optimality bound:</strong> Relate final potential to optimal clustering cost</li>
                            </ol>
                            
                            <h5>Implications:</h5>
                            <ul>
                                <li><strong>Logarithmic guarantee:</strong> Performance degrades slowly with k</li>
                                <li><strong>Probabilistic bound:</strong> Guarantee holds in expectation</li>
                                <li><strong>Initialization only:</strong> Bound applies to initialization, Lloyd's improves it</li>
                                <li><strong>Practical relevance:</strong> Constant factors are reasonable in practice</li>
                            </ul>
                        </div>

                        <div class="interactive-container">
                            <h3>Initialization Comparison Demo</h3>
                            <div class="demo-controls">
                                <label for="init-method">Initialization Method:</label>
                                <select id="init-method">
                                    <option value="random">Random</option>
                                    <option value="kmeans++">K-means++</option>
                                </select>
                                
                                <label for="num-clusters-init">Number of Clusters:</label>
                                <input type="range" id="num-clusters-init" min="2" max="6" value="3">
                                <span id="clusters-init-display">3</span>
                                
                                <button onclick="runInitializationDemo()">Run Demo</button>
                                <button onclick="resetInitializationDemo()">Reset</button>
                            </div>
                            
                            <div class="metric-visualization" id="initialization-canvas">
                                <p>Click "Run Demo" to compare different initialization methods</p>
                            </div>
                        </div>
                    </div>

                    <!-- Optimization Process Section -->
                    <div id="optimization" class="content-section">
                        <h2>Optimization Process</h2>
                        
                        <div class="explanation-box">
                            <p>The K-means optimization process involves iteratively improving the clustering by alternating between assignment and update steps. Understanding this process helps in implementing efficient algorithms and analyzing convergence behavior.</p>
                        </div>

                        <div class="formula-box">
                            <h3>Assignment Step</h3>
                            <div class="formula-display">
                                <h4>Point-to-Cluster Assignment</h4>
                                <div class="formula">cᵢ = argminⱼ ||xᵢ - μⱼ||²</div>
                                <p><strong>Where:</strong></p>
                                <ul>
                                    <li>cᵢ is the cluster assignment for point xᵢ</li>
                                    <li>μⱼ is the centroid of cluster j</li>
                                    <li>argmin finds the cluster with minimum distance</li>
                                </ul>
                            </div>
                        </div>

                        <div class="formula-box">
                            <h3>Update Step</h3>
                            <div class="formula-display">
                                <h4>Centroid Recalculation</h4>
                                <div class="formula">μⱼ = (1/|Sⱼ|) Σᵢ∈Sⱼ xᵢ</div>
                                <p><strong>Where:</strong></p>
                                <ul>
                                    <li>Sⱼ is the set of points assigned to cluster j</li>
                                    <li>|Sⱼ| is the number of points in cluster j</li>
                                    <li>μⱼ is the new centroid for cluster j</li>
                                </ul>
                            </div>
                        </div>

                        <div class="model-box">
                            <h3>Optimization Properties</h3>
                            <ul>
                                <li><strong>Coordinate Descent:</strong> Alternates between optimizing assignments and centroids</li>
                                <li><strong>Monotonic Improvement:</strong> Objective function never increases</li>
                                <li><strong>Finite Convergence:</strong> Guaranteed to converge in finite steps</li>
                                <li><strong>Local Optima:</strong> May converge to local minimum</li>
                            </ul>
                        </div>

                        <div class="interactive-container">
                            <h3>Step-by-Step Optimization Demo</h3>
                            <div class="demo-controls">
                                <button onclick="stepOptimization()">Next Step</button>
                                <button onclick="runFullOptimization()">Run Full Algorithm</button>
                                <button onclick="resetOptimization()">Reset</button>
                            </div>
                            
                            <div class="metric-visualization" id="optimization-canvas">
                                <p>Click "Next Step" to see the optimization process step by step</p>
                            </div>
                        </div>
                    </div>

                    <!-- Convergence Analysis Section -->
                    <div id="convergence" class="content-section">
                        <h2>Convergence Analysis</h2>
                        
                        <div class="explanation-box">
                            <p>Understanding convergence properties is essential for implementing K-means correctly and determining appropriate stopping criteria. The algorithm's convergence behavior affects both computational efficiency and clustering quality.</p>
                        </div>

                        <div class="model-box">
                            <h3>Convergence Criteria</h3>
                            <ul>
                                <li><strong>Centroid Movement:</strong> Stop when centroids move less than threshold</li>
                                <li><strong>Assignment Stability:</strong> Stop when cluster assignments don't change</li>
                                <li><strong>Objective Function:</strong> Stop when WCSS improvement is minimal</li>
                                <li><strong>Maximum Iterations:</strong> Stop after fixed number of iterations</li>
                            </ul>
                        </div>

                        <div class="formula-box">
                            <h3>Convergence Conditions</h3>
                            <div class="formula-display">
                                <h4>Centroid Movement Threshold</h4>
                                <div class="formula">maxᵢ ||μᵢ^(t+1) - μᵢ^(t)|| < ε</div>
                                <p><strong>Where:</strong></p>
                                <ul>
                                    <li>μᵢ^(t) is centroid i at iteration t</li>
                                    <li>ε is the convergence threshold (typically 1e-4)</li>
                                    <li>maxᵢ finds the maximum movement across all centroids</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h3>Convergence Guarantees</h3>
                            <p>K-means is guaranteed to converge because:</p>
                            <ul>
                                <li>The objective function is bounded below by zero</li>
                                <li>Each iteration decreases or maintains the objective function</li>
                                <li>There are only finitely many possible cluster assignments</li>
                                <li>The algorithm cannot cycle due to strict improvement</li>
                            </ul>
                        </div>

                        <div class="image-container">
                            <h4>Visualization: Convergence Behavior</h4>
                            <div class="visualization-placeholder">
                                <p>Graph showing objective function value decreasing over iterations until convergence</p>
                            </div>
                            <p><strong>Convergence Pattern:</strong> Observe how the objective function decreases rapidly in early iterations and then stabilizes.</p>
                        </div>
                    </div>

                    <!-- Interactive Demo Section -->
                    <div id="demo" class="content-section">
                        <h2>Interactive K-means Demo</h2>
                        
                        <div class="explanation-box">
                            <p>Experiment with the K-means algorithm using this interactive demo. Adjust parameters, try different initialization methods, and observe how they affect clustering results and convergence behavior.</p>
                        </div>

                        <div class="interactive-container">
                            <h3>K-means Clustering Demo</h3>
                            
                            <div class="demo-controls">
                                <div class="control-group">
                                    <label for="demo-clusters">Number of Clusters:</label>
                                    <input type="range" id="demo-clusters" min="2" max="8" value="3">
                                    <span id="demo-clusters-display">3</span>
                                </div>
                                
                                <div class="control-group">
                                    <label for="demo-init">Initialization:</label>
                                    <select id="demo-init">
                                        <option value="random">Random</option>
                                        <option value="kmeans++">K-means++</option>
                                    </select>
                                </div>
                                
                                <div class="control-group">
                                    <label for="demo-data">Data Type:</label>
                                    <select id="demo-data">
                                        <option value="blobs">Well-separated Blobs</option>
                                        <option value="random">Random Points</option>
                                        <option value="moons">Moon-shaped</option>
                                    </select>
                                </div>
                                
                                <div class="control-buttons">
                                    <button onclick="generateDemoData()">Generate Data</button>
                                    <button onclick="runKmeansDemo()">Run K-means</button>
                                    <button onclick="stepKmeansDemo()">Step-by-Step</button>
                                    <button onclick="resetDemo()">Reset</button>
                                </div>
                            </div>
                            
                            <div class="demo-status" id="demo-status">
                                <p>Click "Generate Data" to start the demo</p>
                            </div>
                            
                            <div class="metric-visualization" id="kmeans-demo-canvas">
                                <p>Interactive K-means clustering visualization will appear here</p>
                            </div>
                            
                            <div class="demo-metrics" id="demo-metrics" style="display: none;">
                                <h4>Clustering Metrics</h4>
                                <div class="metrics-grid">
                                    <div class="metric-item">
                                        <span class="metric-label">WCSS:</span>
                                        <span class="metric-value" id="wcss-value">-</span>
                                    </div>
                                    <div class="metric-item">
                                        <span class="metric-label">Silhouette:</span>
                                        <span class="metric-value" id="silhouette-value">-</span>
                                    </div>
                                    <div class="metric-item">
                                        <span class="metric-label">Iterations:</span>
                                        <span class="metric-value" id="iterations-value">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quiz Section -->
                    <div id="quiz" class="content-section">
                        <h2>Chapter 4 Quiz</h2>
                        
                        <div class="enhanced-quiz-container">
                            <div class="enhanced-quiz-question">
                                <h4>Question 1: What is the primary objective function minimized by K-means?</h4>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>Between-cluster sum of squares</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="correct">
                                    <p>Within-cluster sum of squares (WCSS)</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>Silhouette coefficient</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>Calinski-Harabasz index</p>
                                </div>
                                <div class="enhanced-quiz-explanation">
                                    <p><strong>Correct!</strong> K-means minimizes the within-cluster sum of squares (WCSS), which measures the total squared distance of all points from their cluster centroids.</p>
                                </div>
                            </div>
                        </div>

                        <div class="enhanced-quiz-container">
                            <div class="enhanced-quiz-question">
                                <h4>Question 2: How are centroids updated in each K-means iteration?</h4>
                                <div class="enhanced-quiz-option" data-answer="correct">
                                    <p>As the arithmetic mean of all points in the cluster</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>As the median of all points in the cluster</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>As the point closest to the cluster center</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>As a weighted average based on point distances</p>
                                </div>
                                <div class="enhanced-quiz-explanation">
                                    <p><strong>Correct!</strong> Centroids are updated as the arithmetic mean of all points assigned to that cluster, which minimizes the WCSS for that cluster.</p>
                                </div>
                            </div>
                        </div>

                        <div class="enhanced-quiz-container">
                            <div class="enhanced-quiz-question">
                                <h4>Question 3: What is the main advantage of K-means++ initialization over random initialization?</h4>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>It's faster to compute</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>It guarantees global optimum</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="correct">
                                    <p>It provides better initialization leading to faster convergence</p>
                                </div>
                                <div class="enhanced-quiz-option" data-answer="incorrect">
                                    <p>It works better with non-spherical clusters</p>
                                </div>
                                <div class="enhanced-quiz-explanation">
                                    <p><strong>Correct!</strong> K-means++ initialization probabilistically selects initial centroids that are well-separated, leading to better starting points and faster convergence to good local minima.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </section>
    </main>

    <!-- Sub-section Navigation Footer -->
    <div class="sub-section-nav-footer">
        <div class="sub-nav-buttons">
            <button id="prev-subsection" class="sub-nav-btn prev-btn" style="display: none;">
                <span>← Previous</span>
                <span class="sub-nav-label" id="prev-label"></span>
            </button>
            <button id="next-subsection" class="sub-nav-btn next-btn">
                <span class="sub-nav-label" id="next-label">Mathematical Foundation</span>
                <span>Next →</span>
            </button>
        </div>
    </div>

    <!-- Chapter Navigation Footer -->
    <div class="navigation-buttons">
        <a href="/tutorials/clustering/chapter7" class="azbn-btn azbn-secondary" onclick="scrollToTop()">← Chapter 7: Optimal K Selection</a>
        <a href="/tutorials/clustering/chapter9" class="azbn-btn azbn-secondary" onclick="scrollToTop()">Chapter 9: DBSCAN Clustering →</a>
    </div>
</body>
</html>
