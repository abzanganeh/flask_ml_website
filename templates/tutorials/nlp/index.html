{% extends "base.html" %}

{% block title %}Complete Interactive NLP Course - {{ site_title }}{% endblock %}

{% block extra_css %}
<style>
/* NLP Course Specific Styles */
.nlp-course-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--space-lg);
}

.nlp-header {
    text-align: center;
    margin-bottom: var(--space-2xl);
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: var(--space-2xl);
    border-radius: var(--radius-lg);
}

.nlp-header h1 {
    color: white;
    margin-bottom: var(--space-md);
}

.progress-bar {
    background: rgba(255,255,255,0.2);
    height: 8px;
    border-radius: 4px;
    margin-top: var(--space-lg);
    overflow: hidden;
}

.progress-fill {
    background: white;
    height: 100%;
    width: 12.5%;
    border-radius: 4px;
    transition: width 0.3s ease;
}

.course-nav {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--space-md);
    margin-bottom: var(--space-2xl);
    background: var(--bg-secondary);
    padding: var(--space-lg);
    border-radius: var(--radius-lg);
}

.nav-btn {
    background: white;
    border: 2px solid #667eea;
    color: #667eea;
    padding: var(--space-sm) var(--space-lg);
    border-radius: var(--radius-full);
    cursor: pointer;
    transition: all var(--transition-fast);
    font-weight: 500;
}

.nav-btn:hover {
    background: #667eea;
    color: white;
}

.nav-btn.active {
    background: #667eea;
    color: white;
}

.nlp-section {
    display: none;
    background: white;
    padding: var(--space-2xl);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-md);
    margin-bottom: var(--space-lg);
}

.nlp-section.active {
    display: block;
}

.nlp-section h2 {
    color: #667eea;
    border-bottom: 2px solid #e5e5f5;
    padding-bottom: var(--space-md);
    margin-bottom: var(--space-lg);
}

.nlp-section h3 {
    color: #764ba2;
    margin-top: var(--space-xl);
    margin-bottom: var(--space-md);
}

.interactive-demo {
    background: linear-gradient(135deg, #f8f9ff 0%, #e5e5f5 100%);
    border: 2px solid #667eea;
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
    margin: var(--space-xl) 0;
}

.interactive-demo h4 {
    color: #667eea;
    margin-bottom: var(--space-md);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.demo-input {
    width: 100%;
    padding: var(--space-md);
    border: 2px solid #ddd;
    border-radius: var(--radius-md);
    font-size: 1rem;
    margin-bottom: var(--space-md);
}

.demo-input:focus {
    outline: none;
    border-color: #667eea;
}

.demo-btn {
    background: #667eea;
    color: white;
    border: none;
    padding: var(--space-md) var(--space-xl);
    border-radius: var(--radius-md);
    cursor: pointer;
    font-weight: 600;
    transition: background var(--transition-fast);
}

.demo-btn:hover {
    background: #5a6fd8;
}

.demo-output {
    background: #eef2ff;
    border: 2px solid #c7d2fe;
    border-left: 5px solid #667eea;
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    margin-top: var(--space-md);
    font-family: 'Courier New', monospace;
    color: #1e40af;
    white-space: pre-wrap;
    min-height: 50px;
}

.formula-box {
    background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%);
    border: 2px solid #fb923c;
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    margin: var(--space-lg) 0;
    font-weight: 600;
}

.example-box {
    background: linear-gradient(135deg, #f0fdf4 0%, #bbf7d0 100%);
    border: 2px solid #22c55e;
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    margin: var(--space-lg) 0;
}

.pros-cons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-lg);
    margin: var(--space-lg) 0;
}

.pros, .cons {
    padding: var(--space-lg);
    border-radius: var(--radius-md);
}

.pros {
    background: linear-gradient(135deg, #f0fdf4 0%, #bbf7d0 100%);
    border: 2px solid #22c55e;
}

.cons {
    background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
    border: 2px solid #ef4444;
}

.architecture-diagram {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-lg);
    margin: var(--space-xl) 0;
    flex-wrap: wrap;
}

.layer {
    background: #667eea;
    color: white;
    padding: var(--space-md) var(--space-lg);
    border-radius: var(--radius-md);
    font-weight: 600;
    text-align: center;
}

.arrow {
    font-size: 1.5rem;
    color: #667eea;
    font-weight: bold;
}

.quiz-container {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    border: 2px solid #f59e0b;
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    margin: var(--space-xl) 0;
}

.quiz-question {
    font-weight: 600;
    margin-bottom: var(--space-md);
    color: #92400e;
}

.quiz-option {
    background: white;
    border: 2px solid #f59e0b;
    border-radius: var(--radius-md);
    padding: var(--space-md);
    margin: var(--space-sm) 0;
    cursor: pointer;
    transition: all var(--transition-fast);
}

.quiz-option:hover {
    background: #fef3c7;
}

.quiz-option.correct {
    background: #dcfce7;
    border-color: #22c55e;
    color: #166534;
}

.quiz-option.incorrect {
    background: #fee2e2;
    border-color: #ef4444;
    color: #991b1b;
}

.attention-visualization {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-sm);
    margin: var(--space-md) 0;
}

.attention-word {
    padding: var(--space-sm) var(--space-md);
    border-radius: var(--radius-md);
    font-weight: 600;
    transition: all var(--transition-fast);
}

@media (max-width: 768px) {
    .course-nav {
        flex-direction: column;
        align-items: center;
    }
    
    .nav-btn {
        width: 100%;
        max-width: 300px;
        text-align: center;
    }
    
    .pros-cons {
        grid-template-columns: 1fr;
    }
    
    .architecture-diagram {
        flex-direction: column;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="container">
    <div class="back-to-tutorials" style="text-align: center; margin-bottom: var(--space-lg);">
        <a href="{{ url_for('tutorials') }}" style="display: inline-flex; align-items: center; gap: var(--space-sm); color: var(--primary-color); text-decoration: none; font-weight: 500;">
            <i class="fas fa-arrow-left"></i> Back to Tutorials
        </a>
    </div>
</div>

<div class="nlp-course-container">
    <!-- Header -->
    <div class="nlp-header">
        <h1>Complete Interactive NLP Course</h1>
        <p>Master Natural Language Processing from fundamentals to advanced Transformers</p>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>
    
    <!-- Navigation -->
    <div class="course-nav">
        <button class="nav-btn active" onclick="showSection('intro')">Introduction</button>
        <button class="nav-btn" onclick="showSection('text-repr')">Text Representation</button>
        <button class="nav-btn" onclick="showSection('embeddings')">Word Embeddings</button>
        <button class="nav-btn" onclick="showSection('sentiment')">Sentiment Analysis</button>
        <button class="nav-btn" onclick="showSection('seq2seq')">Seq2Seq Models</button>
        <button class="nav-btn" onclick="showSection('transformers')">Transformers</button>
        <button class="nav-btn" onclick="showSection('attention')">Self-Attention</button>
        <button class="nav-btn" onclick="showSection('applications')">Applications</button>
    </div>

    <!-- Introduction Section -->
    <div id="intro" class="nlp-section active">
        <h2>Welcome to the NLP Course!</h2>
        
        <p>Natural Language Processing (NLP) is a machine learning technology that gives computers the ability to interpret, manipulate, and comprehend human language. It involves reading, deciphering, understanding, and making sense of human languages.</p>

        <p>In this course, you will learn the fundamentals of NLP, from basic text representation techniques to advanced transformer models like BERT and GPT. Each section includes interactive demos, quizzes, and practical applications.</p>

        <h3>Key Topics Covered</h3>
        <ul>
            <li>Text Representation Techniques</li>
            <li>Word Embeddings (Word2Vec, GloVe, FastText)</li>
            <li>Sentiment Analysis</li>
            <li>Seq2Seq Models</li>
            <li>Transformers and Self-Attention</li>
            <li>Applications in Real-World Scenarios</li>
        </ul>

        <h3> Who This Course is For</h3>
        <p>This course is designed for anyone interested in learning about NLP, from beginners to advanced practitioners. No prior experience with machine learning is required, but familiarity with Python is recommended.</p>

        <div class="interactive-demo">
            <h4>Try NLP in Action!</h4>
            <p>Enter some text to see basic NLP preprocessing:</p>
            <input type="text" class="demo-input" id="nlpInput" placeholder="Enter your text here..." value="Hello! This is a GREAT example of NLP preprocessing.">
            <button class="demo-btn" onclick="preprocessText()">Process Text</button>
            <div class="demo-output" id="nlpOutput">Your processed text will appear here...</div>
        </div>

        <h3> Key Applications of NLP</h3>
        <div class="pros-cons">
            <div class="pros">
                <h4> Communication</h4>
                <ul>
                    <li>Spam Filters (Gmail)</li>
                    <li>Email Classification</li>
                    <li>Chatbots & Virtual Assistants</li>
                    <li>Language Translation</li>
                </ul>
            </div>
            <div class="cons">
                <h4> Business Intelligence</h4>
                <ul>
                    <li>Sentiment Analysis</li>
                    <li>Market Research</li>
                    <li>Algorithmic Trading</li>
                    <li>Document Summarization</li>
                </ul>
            </div>
        </div>

        <div class="quiz-container">
            <div class="quiz-question">Quick Quiz: Which of these is NOT a typical NLP application?</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">A) Email spam detection</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">B) Language translation</div>
            <div class="quiz-option" onclick="checkAnswer(this, true)">C) Image object detection</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">D) Sentiment analysis</div>
        </div>
    </div>

    <!-- Text Representation Section -->
    <div id="text-repr" class="nlp-section">
        <h2>Text Representation Techniques</h2>
        
        <h3>1. Bag of Words (BoW)</h3>
        <p>BoW represents text by the frequency of words within a document, ignoring grammar and word order.</p>

        <div class="interactive-demo">
            <h4>Bag of Words Demo</h4>
            <input type="text" class="demo-input" id="bowInput" placeholder="Enter sentences separated by | (e.g., I love NLP | NLP is amazing)" value="I love machine learning | Machine learning is powerful">
            <button class="demo-btn" onclick="demonstrateBOW()">Create BoW</button>
            <div class="demo-output" id="bowOutput">Your BoW representation will appear here...</div>
        </div>

        <div class="pros-cons">
            <div class="pros">
                <h4>Advantages</h4>
                <ul>
                    <li>Simple and easy to implement</li>
                    <li>Works well for text classification</li>
                    <li>Computationally efficient</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Disadvantages</h4>
                <ul>
                    <li>High dimensionality</li>
                    <li>Sparse features</li>
                    <li>Treats synonyms differently</li>
                    <li>Ignores word order</li>
                </ul>
            </div>
        </div>

        <h3>2. TF-IDF (Term Frequency-Inverse Document Frequency)</h3>
        <p>TF-IDF reflects the importance of a word in a document relative to a collection of documents.</p>

        <div class="formula-box">
            <strong>Formula:</strong><br>
            TF-IDF(t,d) = TF(t,d) √ó IDF(t)<br>
            Where:<br>
            ‚Ä¢ TF = (Number of times term appears in document) / (Total number of terms in document)<br>
            ‚Ä¢ IDF = log(Total number of documents / Number of documents containing the term)
        </div>

        <div class="interactive-demo">
            <h4>TF-IDF Demo</h4>
            <input type="text" class="demo-input" id="tfidfInput" placeholder="Enter documents separated by |" value="The cat sat on the mat | The dog ran in the park | Cats and dogs are pets">
            <button class="demo-btn" onclick="demonstrateTFIDF()">Calculate TF-IDF</button>
            <div class="demo-output" id="tfidfOutput">TF-IDF calculations will appear here...</div>
        </div>
    </div>

    <!-- Word Embeddings Section -->
    <div id="embeddings" class="nlp-section">
        <h2>Word Embeddings</h2>
        
        <p>Word embeddings are dense vector representations of words that capture their semantic meaning. Unlike BoW and TF-IDF, embeddings consider the context in which words appear.</p>

        <div class="example-box">
            <strong>Famous Example:</strong><br>
            king - man + woman = queen<br>
            This demonstrates how embeddings capture semantic relationships!
        </div>

        <h3>1. Word2Vec</h3>
        <p>Word2Vec uses neural networks to learn word associations from a large corpus of text.</p>

        <div class="architecture-diagram">
            <div class="layer">Input Layer</div>
            <span class="arrow">‚Üí</span>
            <div class="layer">Hidden Layer (Embeddings)</div>
            <span class="arrow">‚Üí</span>
            <div class="layer">Output Layer</div>
        </div>

        <div class="interactive-demo">
            <h4>Word Similarity Demo</h4>
            <p>Enter two words to see their conceptual similarity:</p>
            <input type="text" class="demo-input" id="word1" placeholder="First word" value="king">
            <input type="text" class="demo-input" id="word2" placeholder="Second word" value="queen">
            <button class="demo-btn" onclick="calculateWordSimilarity()">Calculate Similarity</button>
            <div class="demo-output" id="similarityOutput">Similarity analysis will appear here...</div>
        </div>

        <h3>Word2Vec Variants</h3>
        <div class="pros-cons">
            <div class="pros">
                <h4>CBOW (Continuous Bag of Words)</h4>
                <ul>
                    <li>Predicts target word from context</li>
                    <li>Faster training</li>
                    <li>Better for frequent words</li>
                    <li>Good for large datasets</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Skip-gram</h4>
                <ul>
                    <li>Predicts context from target word</li>
                    <li>Better for rare words</li>
                    <li>Higher accuracy</li>
                    <li>Good for small datasets</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Sentiment Analysis Section -->
    <div id="sentiment" class="nlp-section">
        <h2>Sentiment Analysis</h2>
        
        <p>Sentiment analysis determines the emotional tone behind words, helping understand opinions, attitudes, and emotions expressed in text.</p>

        <div class="interactive-demo">
            <h4>Live Sentiment Analysis</h4>
            <input type="text" class="demo-input" id="sentimentInput" placeholder="Enter text to analyze sentiment..." value="I love this amazing product! It works perfectly.">
            <button class="demo-btn" onclick="analyzeSentiment()">Analyze Sentiment</button>
            <div class="demo-output" id="sentimentOutput"></div>
        </div>

        <h3>Sentiment Analysis Workflow</h3>
        <div class="architecture-diagram">
            <div class="layer">Data Collection</div>
            <span class="arrow">‚Üí</span>
            <div class="layer">Preprocessing</div>
            <span class="arrow">‚Üí</span>
            <div class="layer">Feature Extraction</div>
            <span class="arrow">‚Üí</span>
            <div class="layer">Model Training</div>
            <span class="arrow">‚Üí</span>
            <div class="layer">Evaluation</div>
        </div>

        <h3>Applications</h3>
        <div class="pros-cons">
            <div class="pros">
                <h4>Business Applications</h4>
                <ul>
                    <li>Brand reputation monitoring</li>
                    <li>Product review analysis</li>
                    <li>Customer feedback processing</li>
                    <li>Market research</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Social & Political</h4>
                <ul>
                    <li>Social media monitoring</li>
                    <li>Political opinion tracking</li>
                    <li>Public sentiment analysis</li>
                    <li>Crisis management</li>
                </ul>
            </div>
        </div>

        <h3>Challenges in Sentiment Analysis</h3>
        <ul>
            <li><strong>Sarcasm Detection:</strong> "Great job!" might be sarcastic</li>
            <li><strong>Context Dependency:</strong> Same word, different sentiments</li>
            <li><strong>Imbalanced Datasets:</strong> More positive than negative examples</li>
            <li><strong>Domain Specificity:</strong> Movie reviews vs. product reviews</li>
        </ul>

        <div class="quiz-container">
            <div class="quiz-question">Quiz: Which is the biggest challenge in sentiment analysis?</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">A) Processing speed</div>
            <div class="quiz-option" onclick="checkAnswer(this, true)">B) Understanding context and sarcasm</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">C) Memory requirements</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">D) Data storage</div>
        </div>
    </div>

    <!-- Seq2Seq Section -->
    <div id="seq2seq" class="nlp-section">
        <h2>Sequence-to-Sequence Models</h2>
        
        <p>Seq2Seq models are specialized neural network architectures designed to handle sequences as both input and output. They're perfect for tasks like translation, summarization, and chatbots.</p>

        <div class="architecture-diagram">
            <h3>Seq2Seq Architecture</h3>
            <div class="layer">Encoder</div>
            <span class="arrow">‚Üí</span>
            <div class="layer">Context Vector</div>
            <span class="arrow">‚Üí</span>
            <div class="layer">Decoder</div>
        </div>

        <div class="interactive-demo">
            <h4>Translation Demo (Conceptual)</h4>
            <input type="text" class="demo-input" id="translateInput" placeholder="Enter English text..." value="Hello how are you today">
            <select class="demo-input" id="targetLang">
                <option value="spanish">Spanish</option>
                <option value="french">French</option>
                <option value="german">German</option>
            </select>
            <button class="demo-btn" onclick="demonstrateTranslation()">Translate</button>
            <div class="demo-output" id="translateOutput"></div>
        </div>

        <h3>Key Components</h3>
        
        <div class="example-box">
            <h4>Encoder</h4>
            <p>Processes each token in the input sequence and creates a fixed-length context vector that encapsulates the meaning of the entire input sequence.</p>
        </div>

        <div class="example-box">
            <h4>Context Vector</h4>
            <p>The final internal state of the encoder - a dense representation that captures the essence of the input sequence.</p>
        </div>

        <div class="example-box">
            <h4>Decoder</h4>
            <p>Reads the context vector and generates the target sequence token by token, using the context and previously generated tokens.</p>
        </div>

        <h3>Types of Seq2Seq Models</h3>
        <ul>
            <li><strong>Many-to-One:</strong> Sentiment analysis (sequence ‚Üí single label)</li>
            <li><strong>One-to-Many:</strong> Image captioning (image ‚Üí sequence of words)</li>
            <li><strong>Many-to-Many:</strong> Machine translation (sequence ‚Üí sequence)</li>
            <li><strong>Synchronized:</strong> Video classification (frame by frame)</li>
        </ul>

        <h3>Limitations</h3>
        <div class="pros-cons">
            <div class="cons">
                <h4>RNN/LSTM Based Seq2Seq Issues</h4>
                <ul>
                    <li>Vanishing gradient problems</li>
                    <li>Sequential processing (no parallelization)</li>
                    <li>Information bottleneck in context vector</li>
                    <li>Difficulty with long sequences</li>
                </ul>
            </div>
            <div class="pros">
                <h4>Solutions</h4>
                <ul>
                    <li>Attention mechanisms</li>
                    <li>Transformer architecture</li>
                    <li>Better initialization techniques</li>
                    <li>Advanced optimization methods</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Transformers Section -->
    <div id="transformers" class="nlp-section">
        <h2>Transformers: The Revolution</h2>
        
        <p>Transformers revolutionized NLP by introducing the "Attention is All You Need" paradigm, eliminating the need for recurrent connections while achieving superior performance.</p>

        <div class="example-box">
            <h4>Key Innovation: Self-Attention</h4>
            <p>Instead of processing sequences step-by-step, Transformers look at all positions simultaneously and learn which parts are most relevant to each other.</p>
        </div>

        <div class="interactive-demo">
            <h4>Transformer Components Explorer</h4>
            <select class="demo-input" id="transformerComponent">
                <option value="overview">Architecture Overview</option>
                <option value="encoder">Encoder Stack</option>
                <option value="decoder">Decoder Stack</option>
                <option value="attention">Multi-Head Attention</option>
            </select>
            <button class="demo-btn" onclick="exploreTransformer()">Explore Component</button>
            <div class="demo-output" id="transformerOutput"></div>
        </div>

        <h3>Transformer Architecture</h3>
        <div class="architecture-diagram">
            <div style="display: flex; justify-content: space-between; width: 100%;">
                <div style="text-align: center;">
                    <h4>Encoder</h4>
                    <div class="layer">Multi-Head Attention</div>
                    <div class="layer">Add & Norm</div>
                    <div class="layer">Feed Forward</div>
                    <div class="layer">Add & Norm</div>
                    <p>√ó6 layers</p>
                </div>
                <div style="text-align: center;">
                    <h4>Decoder</h4>
                    <div class="layer">Masked Multi-Head Attention</div>
                    <div class="layer">Add & Norm</div>
                    <div class="layer">Multi-Head Attention</div>
                    <div class="layer">Add & Norm</div>
                    <div class="layer">Feed Forward</div>
                    <div class="layer">Add & Norm</div>
                    <p>√ó6 layers</p>
                </div>
            </div>
        </div>

        <h3>Why Transformers?</h3>
        <div class="pros-cons">
            <div class="pros">
                <h4>Advantages</h4>
                <ul>
                    <li><strong>Parallelization:</strong> Process entire sequences simultaneously</li>
                    <li><strong>Long-term Dependencies:</strong> Better at capturing relationships</li>
                    <li><strong>Scalability:</strong> Easy to scale to larger datasets</li>
                    <li><strong>Transfer Learning:</strong> Pre-trained models work across tasks</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Limitations</h4>
                <ul>
                    <li><strong>Computational Cost:</strong> Quadratic complexity with sequence length</li>
                    <li><strong>Data Hungry:</strong> Requires large amounts of training data</li>
                    <li><strong>Memory Requirements:</strong> High memory usage</li>
                    <li><strong>Overfitting:</strong> Prone to overfitting on small datasets</li>
                </ul>
            </div>
        </div>

        <h3>Famous Transformer Models</h3>
        <ul>
            <li><strong>BERT:</strong> Bidirectional Encoder Representations from Transformers</li>
            <li><strong>GPT:</strong> Generative Pre-trained Transformer</li>
            <li><strong>T5:</strong> Text-to-Text Transfer Transformer</li>
            <li><strong>RoBERTa:</strong> Robustly Optimized BERT Pretraining Approach</li>
        </ul>
    </div>

    <!-- Self-Attention Section -->
    <div id="attention" class="nlp-section">
        <h2>Self-Attention Mechanism</h2>
        
        <p>Self-attention is the core innovation of Transformers. It allows each position in a sequence to attend to all positions in the same sequence to compute a representation.</p>

        <div class="interactive-demo">
            <h4>Attention Visualization</h4>
            <input type="text" class="demo-input" id="attentionInput" placeholder="Enter a sentence to visualize attention..." value="The cat sat on the mat">
            <button class="demo-btn" onclick="visualizeAttention()">Visualize Attention</button>
            <div class="demo-output" id="attentionOutput"></div>
        </div>

        <h3>How Self-Attention Works</h3>
        
        <div class="example-box">
            <h4>Key Components</h4>
            <ul>
                <li><strong>Query (Q):</strong> What information are we looking for?</li>
                <li><strong>Key (K):</strong> What information does each position offer?</li>
                <li><strong>Value (V):</strong> The actual information to be retrieved</li>
            </ul>
        </div>

        <div class="formula-box">
Attention(Q, K, V) = softmax(QK^T / ‚àöd_k)V

Where:
- Q, K, V are matrices of queries, keys, and values
- d_k is the dimension of the key vectors
- ‚àöd_k is used for scaling to prevent extremely small gradients
        </div>

        <div class="interactive-demo">
            <h4>Step-by-Step Attention Calculation</h4>
            <button class="demo-btn" onclick="demonstrateAttentionSteps()">Show Attention Steps</button>
            <div class="demo-output" id="attentionStepsOutput"></div>
        </div>

        <h3>Multi-Head Attention</h3>
        <p>Instead of performing a single attention function, multi-head attention runs multiple attention "heads" in parallel, each focusing on different types of relationships.</p>

        <div class="architecture-diagram">
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                <div class="layer">Head 1</div>
                <div class="layer">Head 2</div>
                <div class="layer">Head 3</div>
                <div class="layer">...</div>
                <div class="layer">Head 8</div>
            </div>
            <div style="text-align: center; margin: 20px 0;">
                <span class="arrow">‚Üì</span>
            </div>
            <div class="layer">Concatenate & Linear</div>
        </div>

        <div class="interactive-demo">
            <h4>Multi-Head Attention Demo</h4>
            <input type="number" class="demo-input" id="numHeads" min="1" max="8" value="4" placeholder="Number of attention heads">
            <button class="demo-btn" onclick="demonstrateMultiHead()">Simulate Multi-Head</button>
            <div class="demo-output" id="multiHeadOutput"></div>
        </div>

        <div class="quiz-container">
            <div class="quiz-question">Quiz: What is the main advantage of multi-head attention?</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">A) Faster computation</div>
            <div class="quiz-option" onclick="checkAnswer(this, true)">B) Captures different types of relationships simultaneously</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">C) Uses less memory</div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">D) Simpler to implement</div>
        </div>
    </div>

    <!-- Applications Section -->
    <div id="applications" class="nlp-section">
        <h2>Modern NLP Applications</h2>
        
        <p>Modern NLP has enabled countless applications that we use daily. Let's explore some cutting-edge applications and try them out!</p>

        <div class="interactive-demo">
            <h4>Text Summarization</h4>
            <textarea class="demo-input" id="summaryInput" rows="5" placeholder="Enter a long text to summarize...">Natural Language Processing (NLP) is a branch of artificial intelligence that helps computers understand, interpret and manipulate human language. NLP draws from many disciplines, including computer science and computational linguistics, in its pursuit to fill the gap between human communication and computer understanding. The ultimate objective of NLP is to read, decipher, understand, and make sense of the human languages in a manner that is valuable. Most NLP techniques rely on machine learning to derive meaning from human languages.</textarea>
            <button class="demo-btn" onclick="summarizeText()">Summarize</button>
            <div class="demo-output" id="summaryOutput"></div>
        </div>

        <div class="interactive-demo">
            <h4>Named Entity Recognition (NER)</h4>
            <input type="text" class="demo-input" id="nerInput" placeholder="Enter text with names, places, organizations..." value="Apple Inc. was founded by Steve Jobs in Cupertino, California in 1976.">
            <button class="demo-btn" onclick="performNER()">Extract Entities</button>
            <div class="demo-output" id="nerOutput"></div>
        </div>

        <div class="interactive-demo">
            <h4>Question Answering</h4>
            <textarea class="demo-input" id="qaContext" rows="3" placeholder="Enter context...">The Transformer is a deep learning model introduced in 2017, used primarily in the field of natural language processing. Like recurrent neural networks, transformers are designed to handle sequential input data, such as natural language, for tasks such as translation and text summarization.</textarea>
            <input type="text" class="demo-input" id="qaQuestion" placeholder="Ask a question about the context..." value="When was the Transformer model introduced?">
            <button class="demo-btn" onclick="answerQuestion()">Answer Question</button>
            <div class="demo-output" id="qaOutput"></div>
        </div>

        <h3>Industry Applications</h3>
        <div class="pros-cons">
            <div class="pros">
                <h4>Healthcare</h4>
                <ul>
                    <li>Medical record analysis</li>
                    <li>Drug discovery assistance</li>
                    <li>Clinical decision support</li>
                    <li>Patient interaction chatbots</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Finance</h4>
                <ul>
                    <li>Fraud detection</li>
                    <li>Risk assessment</li>
                    <li>Algorithmic trading</li>
                    <li>Customer service automation</li>
                </ul>
            </div>
        </div>

        <div class="pros-cons">
            <div class="pros">
                <h4>Education</h4>
                <ul>
                    <li>Automated essay scoring</li>
                    <li>Personalized learning</li>
                    <li>Language learning apps</li>
                    <li>Research assistance</li>
                </ul>
            </div>
            <div class="cons">
                <h4>E-commerce</h4>
                <ul>
                    <li>Product recommendations</li>
                    <li>Review analysis</li>
                    <li>Customer support</li>
                    <li>Search optimization</li>
                </ul>
            </div>
        </div>

        <h3>Future of NLP</h3>
        <ul>
            <li><strong>Multimodal Models:</strong> Combining text, images, and audio</li>
            <li><strong>Few-shot Learning:</strong> Learning from minimal examples</li>
            <li><strong>Efficient Models:</strong> Smaller, faster models for mobile devices</li>
            <li><strong>Ethical AI:</strong> Reducing bias and improving fairness</li>
            <li><strong>Specialized Models:</strong> Domain-specific fine-tuned models</li>
        </ul>

        <div class="example-box">
            <h4>Congratulations!</h4>
            <p>You've completed the comprehensive NLP course! You now understand the fundamental concepts from basic text representation to advanced Transformer architectures. Keep practicing and exploring to master these powerful techniques!</p>
        </div>
    </div>
    
</div>
{% endblock %}

{% block extra_js %}
<script>
let currentSection = 'intro';
const sections = ['intro', 'text-repr', 'embeddings', 'sentiment', 'seq2seq', 'transformers', 'attention', 'applications'];

function showSection(sectionId) {
    // Hide all sections
    document.querySelectorAll('.nlp-section').forEach(section => {
        section.classList.remove('active');
    });
    
    // Show target section
    document.getElementById(sectionId).classList.add('active');
    
    // Update navigation
    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Update progress
    const progress = (sections.indexOf(sectionId) + 1) / sections.length * 100;
    document.getElementById('progressFill').style.width = progress + '%';
    
    currentSection = sectionId;
}

function preprocessText() {
    const input = document.getElementById('nlpInput').value;
    const output = document.getElementById('nlpOutput');
    
    if (!input.trim()) {
        output.textContent = 'Please enter some text to process.';
        return;
    }
    
    // Simple preprocessing simulation
    const steps = [
        `Original: "${input}"`,
        `Lowercased: "${input.toLowerCase()}"`,
        `Tokens: [${input.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).map(w => `"${w}"`).join(', ')}]`,
        `Filtered (no stopwords): [${input.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => !['the', 'is', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(w)).map(w => `"${w}"`).join(', ')}]`
    ];
    
    output.innerHTML = steps.join('<br>');
}

function demonstrateBOW() {
    const input = document.getElementById('bowInput').value;
    const output = document.getElementById('bowOutput');
    
    if (!input.trim()) {
        output.textContent = 'Please enter some documents separated by |';
        return;
    }
    
    const documents = input.split('|').map(doc => doc.trim());
    const allWords = new Set();
    
    // Collect all unique words
    documents.forEach(doc => {
        const words = doc.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
        words.forEach(word => allWords.add(word));
    });
    
    const vocabulary = Array.from(allWords).sort();
    
    // Create BoW vectors
    let result = `<strong>Vocabulary:</strong> [${vocabulary.join(', ')}]<br><br>`;
    
    documents.forEach((doc, i) => {
        const words = doc.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
        const vector = vocabulary.map(word => words.includes(word) ? 1 : 0);
        result += `<strong>Document ${i + 1}:</strong> "${doc}"<br>`;
        result += `<strong>BoW Vector:</strong> [${vector.join(', ')}]<br><br>`;
    });
    
    output.innerHTML = result;
}

function demonstrateTFIDF() {
    const input = document.getElementById('tfidfInput').value;
    const output = document.getElementById('tfidfOutput');
    
    if (!input.trim()) {
        output.textContent = 'Please enter some documents separated by |';
        return;
    }
    
    const documents = input.split('|').map(doc => doc.trim());
    const allWords = new Set();
    
    // Collect all unique words
    documents.forEach(doc => {
        const words = doc.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
        words.forEach(word => allWords.add(word));
    });
    
    const vocabulary = Array.from(allWords).sort();
    
    let result = '<strong>TF-IDF Calculation:</strong><br><br>';
    
    documents.forEach((doc, i) => {
        const words = doc.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
        const wordCount = {};
        words.forEach(word => wordCount[word] = (wordCount[word] || 0) + 1);
        
        result += `<strong>Document ${i + 1}:</strong> "${doc}"<br>`;
        
        vocabulary.forEach(word => {
            const tf = (wordCount[word] || 0) / words.length;
            const docsWithWord = documents.filter(d => 
                d.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).includes(word)
            ).length;
            const idf = Math.log(documents.length / docsWithWord);
            const tfidf = tf * idf;
            
            if (tfidf > 0) {
                result += `&nbsp;&nbsp;${word}: TF=${tf.toFixed(3)}, IDF=${idf.toFixed(3)}, TF-IDF=${tfidf.toFixed(3)}<br>`;
            }
        });
        result += '<br>';
    });
    
    output.innerHTML = result;
}

function calculateWordSimilarity() {
    const word1 = document.getElementById('word1').value.toLowerCase();
    const word2 = document.getElementById('word2').value.toLowerCase();
    const output = document.getElementById('similarityOutput');
    
    if (!word1 || !word2) {
        output.textContent = 'Please enter both words.';
        return;
    }
    
    // Simulated similarity based on conceptual relationships
    const similarities = {
        'king,queen': 0.85, 'queen,king': 0.85,
        'man,woman': 0.75, 'woman,man': 0.75,
        'dog,cat': 0.70, 'cat,dog': 0.70,
        'happy,joy': 0.80, 'joy,happy': 0.80,
        'computer,laptop': 0.85, 'laptop,computer': 0.85,
        'car,vehicle': 0.80, 'vehicle,car': 0.80
    };
    
    const key = `${word1},${word2}`;
    const similarity = similarities[key] || (Math.random() * 0.5 + 0.2); // Random similarity for demo
    
    output.innerHTML = `
        <strong>Similarity Analysis:</strong><br>
        Word 1: "${word1}"<br>
        Word 2: "${word2}"<br>
        <strong>Cosine Similarity: ${similarity.toFixed(3)}</strong><br>
        <em>Note: This is a simplified demonstration. Real embeddings require trained models.</em>
    `;
}

function analyzeSentiment() {
    const input = document.getElementById('sentimentInput').value;
    const output = document.getElementById('sentimentOutput');
    
    if (!input.trim()) {
        output.textContent = 'Please enter some text to analyze.';
        return;
    }
    
    // Simple rule-based sentiment analysis for demo
    const positiveWords = ['love', 'amazing', 'great', 'excellent', 'wonderful', 'fantastic', 'good', 'perfect', 'awesome', 'brilliant'];
    const negativeWords = ['hate', 'terrible', 'awful', 'bad', 'horrible', 'disgusting', 'worst', 'disappointing', 'poor', 'useless'];
    
    const words = input.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
    
    let positiveScore = 0;
    let negativeScore = 0;
    
    words.forEach(word => {
        if (positiveWords.includes(word)) positiveScore++;
        if (negativeWords.includes(word)) negativeScore++;
    });
    
    let sentiment, confidence, emoji;
    if (positiveScore > negativeScore) {
        sentiment = 'Positive';
        confidence = ((positiveScore / (positiveScore + negativeScore + 1)) * 100).toFixed(1);
        emoji = 'üòä';
    } else if (negativeScore > positiveScore) {
        sentiment = 'Negative';
        confidence = ((negativeScore / (positiveScore + negativeScore + 1)) * 100).toFixed(1);
        emoji = 'üòû';
    } else {
        sentiment = 'Neutral';
        confidence = '50.0';
        emoji = 'üòê';
    }
    
    output.innerHTML = `
        <div style="text-align: center; font-size: 2em; margin: 10px 0;">${emoji}</div>
        <strong>Sentiment:</strong> ${sentiment}<br>
        <strong>Confidence:</strong> ${confidence}%<br>
        <strong>Analysis:</strong><br>
        ‚Ä¢ Positive words found: ${positiveScore}<br>
        ‚Ä¢ Negative words found: ${negativeScore}<br>
        <em>Note: This is a simplified demonstration using rule-based analysis.</em>
    `;
}

function demonstrateTranslation() {
    const input = document.getElementById('translateInput').value;
    const targetLang = document.getElementById('targetLang').value;
    const output = document.getElementById('translateOutput');
    
    // Simple mock translations for demo
    const translations = {
        'spanish': {
            'hello': 'hola',
            'how': 'c√≥mo',
            'are': 'est√°s',
            'you': 't√∫',
            'today': 'hoy',
            'good': 'bueno',
            'morning': 'ma√±ana',
            'thank': 'gracias',
            'please': 'por favor'
        },
        'french': {
            'hello': 'bonjour',
            'how': 'comment',
            'are': '√™tes',
            'you': 'vous',
            'today': 'aujourd\'hui',
            'good': 'bon',
            'morning': 'matin',
            'thank': 'merci',
            'please': 's\'il vous pla√Æt'
        },
        'german': {
            'hello': 'hallo',
            'how': 'wie',
            'are': 'sind',
            'you': 'sie',
            'today': 'heute',
            'good': 'gut',
            'morning': 'morgen',
            'thank': 'danke',
            'please': 'bitte'
        }
    };
    
    const words = input.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
    const translatedWords = words.map(word => 
        translations[targetLang][word] || word
    );
    
    output.innerHTML = `
        <strong>Original (English):</strong> ${input}<br>
        <strong>Translated (${targetLang.charAt(0).toUpperCase() + targetLang.slice(1)}):</strong> ${translatedWords.join(' ')}<br>
        <em>Note: This is a simplified word-by-word translation for demonstration.</em>
    `;
}

function exploreTransformer() {
    const component = document.getElementById('transformerComponent').value;
    const output = document.getElementById('transformerOutput');
    
    const explanations = {
        'overview': `
            <strong>Transformer Architecture Overview:</strong><br><br>
            The Transformer consists of:<br>
            ‚Ä¢ <strong>Encoder Stack:</strong> 6 identical layers processing input<br>
            ‚Ä¢ <strong>Decoder Stack:</strong> 6 identical layers generating output<br>
            ‚Ä¢ <strong>Input/Output Embeddings:</strong> Convert tokens to vectors<br>
            ‚Ä¢ <strong>Positional Encoding:</strong> Add position information<br><br>
            <em>Key Innovation: No recurrence, only attention!</em>
        `,
        'encoder': `
            <strong>Encoder Stack Details:</strong><br><br>
            Each encoder layer contains:<br>
            1. <strong>Multi-Head Self-Attention:</strong> Looks at other positions in input<br>
            2. <strong>Add & Norm:</strong> Residual connection + layer normalization<br>
            3. <strong>Feed-Forward Network:</strong> Two linear transformations with ReLU<br>
            4. <strong>Add & Norm:</strong> Another residual connection + normalization<br><br>
            <em>Output: Rich contextual representations of input sequence</em>
        `,
        'decoder': `
            <strong>Decoder Stack Details:</strong><br><br>
            Each decoder layer contains:<br>
            1. <strong>Masked Multi-Head Attention:</strong> Prevents looking at future tokens<br>
            2. <strong>Add & Norm:</strong> Residual connection + normalization<br>
            3. <strong>Encoder-Decoder Attention:</strong> Attends to encoder output<br>
            4. <strong>Add & Norm:</strong> Another residual connection<br>
            5. <strong>Feed-Forward Network:</strong> Final processing<br>
            6. <strong>Add & Norm:</strong> Final residual connection<br><br>
            <em>Output: Generated sequence (e.g., translation)</em>
        `,
        'attention': `
            <strong>Multi-Head Attention:</strong><br><br>
            Instead of single attention:<br>
            ‚Ä¢ <strong>8 parallel attention heads</strong> (typically)<br>
            ‚Ä¢ Each head learns different relationships<br>
            ‚Ä¢ Results are concatenated and linearly transformed<br><br>
            Benefits:<br>
            ‚Ä¢ Head 1: Syntactic relationships<br>
            ‚Ä¢ Head 2: Semantic relationships<br>
            ‚Ä¢ Head 3: Long-distance dependencies<br>
            ‚Ä¢ ... and so on<br><br>
            <em>Like having multiple experts examining the same data!</em>
        `
    };
    
    output.innerHTML = explanations[component];
}

function visualizeAttention() {
    const input = document.getElementById('attentionInput').value;
    const output = document.getElementById('attentionOutput');
    
    const words = input.split(/\s+/);
    if (words.length === 0) return;
    
    // Simple attention simulation - word focuses most on nearby words
    let visualization = '<div class="attention-visualization">';
    
    words.forEach((word, i) => {
        // Generate random attention weights favoring nearby words
        const weights = words.map((_, j) => {
            const distance = Math.abs(i - j);
            return Math.max(0.1, 1 - distance * 0.3 + Math.random() * 0.2);
        });
        
        // Normalize weights
        const sum = weights.reduce((a, b) => a + b, 0);
        const normalizedWeights = weights.map(w => w / sum);
        
        // Find max weight for color intensity
        const maxWeight = Math.max(...normalizedWeights);
        const intensity = Math.floor((normalizedWeights[i] / maxWeight) * 255);
        const color = `rgb(${255-intensity}, ${255-intensity}, 255)`;
        
        visualization += `<div class="attention-word" style="background-color: ${color}; border: 2px solid #667eea;">${word}</div>`;
    });
    
    visualization += '</div>';
    visualization += '<p><em>Color intensity represents attention weight (darker = higher attention)</em></p>';
    
    output.innerHTML = visualization;
}

function demonstrateAttentionSteps() {
    const output = document.getElementById('attentionStepsOutput');
    
    output.innerHTML = `
        <strong>Step-by-Step Attention Calculation:</strong><br><br>
        
        <strong>Step 1: Create Q, K, V matrices</strong><br>
        ‚Ä¢ Query (Q) = Input √ó W_Q<br>
        ‚Ä¢ Key (K) = Input √ó W_K<br>
        ‚Ä¢ Value (V) = Input √ó W_V<br><br>
        
        <strong>Step 2: Calculate attention scores</strong><br>
        ‚Ä¢ Scores = Q √ó K^T<br>
        ‚Ä¢ Example: [0.8, 0.2, 0.1, 0.9]<br><br>
        
        <strong>Step 3: Scale by ‚àöd_k</strong><br>
        ‚Ä¢ Scaled = Scores / ‚àö64 = Scores / 8<br>
        ‚Ä¢ Prevents extremely small gradients<br><br>
        
        <strong>Step 4: Apply softmax</strong><br>
        ‚Ä¢ Weights = softmax([0.1, 0.025, 0.0125, 0.1125])<br>
        ‚Ä¢ Weights = [0.28, 0.23, 0.22, 0.27]<br><br>
        
        <strong>Step 5: Weighted sum of values</strong><br>
        ‚Ä¢ Output = Weights √ó V<br>
        ‚Ä¢ Final contextualized representation!<br><br>
        
        <em>This happens for every position in parallel!</em>
    `;
}

function demonstrateMultiHead() {
    const numHeads = document.getElementById('numHeads').value;
    const output = document.getElementById('multiHeadOutput');
    
    let result = `<strong>Multi-Head Attention with ${numHeads} heads:</strong><br><br>`;
    
    for (let i = 1; i <= numHeads; i++) {
        const focus = ['syntactic relations', 'semantic meaning', 'long-distance deps', 'local context', 'coreference', 'temporal relations', 'causal relations', 'thematic roles'][i-1] || 'specialized patterns';
        result += `<strong>Head ${i}:</strong> Focuses on ${focus}<br>`;
    }
    
    result += `<br><strong>Process:</strong><br>`;
    result += `1. Each head computes its own Q, K, V matrices<br>`;
    result += `2. Each head produces attention output independently<br>`;
    result += `3. All head outputs are concatenated<br>`;
    result += `4. Final linear transformation combines information<br><br>`;
    result += `<em>Result: Rich, multi-faceted understanding of relationships!</em>`;
    
    output.innerHTML = result;
}

function summarizeText() {
    const input = document.getElementById('summaryInput').value;
    const output = document.getElementById('summaryOutput');
    
    // Simple extractive summarization simulation
    const sentences = input.split(/[.!?]+/).filter(s => s.trim().length > 0);
    
    if (sentences.length <= 2) {
        output.innerHTML = '<em>Text is already concise!</em>';
        return;
    }
    
    // Score sentences based on keyword frequency (simplified)
    const words = input.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
    const wordFreq = {};
    words.forEach(word => {
        if (word.length > 3) { // Ignore short words
            wordFreq[word] = (wordFreq[word] || 0) + 1;
        }
    });
    
    const sentenceScores = sentences.map(sentence => {
        const sentWords = sentence.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
        const score = sentWords.reduce((sum, word) => sum + (wordFreq[word] || 0), 0);
        return { sentence: sentence.trim() + '.', score: score / sentWords.length };
    });
    
    // Take top 2 sentences
    const topSentences = sentenceScores
        .sort((a, b) => b.score - a.score)
        .slice(0, 2)
        .map(item => item.sentence);
    
    output.innerHTML = `
        <strong>Summary:</strong><br>
        ${topSentences.join(' ')}<br><br>
        <em>Note: This is a simplified extractive summarization for demonstration.</em>
    `;
}

function performNER() {
    const input = document.getElementById('nerInput').value;
    const output = document.getElementById('nerOutput');
    
    // Simple named entity recognition patterns
    const patterns = [
        { regex: /\b[A-Z][a-z]+ Inc\.\b/g, type: 'ORGANIZATION', color: '#ff6b6b' },
        { regex: /\b[A-Z][a-z]+ [A-Z][a-z]+\b/g, type: 'PERSON', color: '#4ecdc4' },
        { regex: /\b[A-Z][a-z]+(?:, [A-Z][a-z]+)?\b/g, type: 'LOCATION', color: '#45b7d1' },
        { regex: /\b\d{4}\b/g, type: 'DATE', color: '#96ceb4' }
    ];
    
    let processedText = input;
    const entities = [];
    
    patterns.forEach(pattern => {
        const matches = input.match(pattern.regex);
        if (matches) {
            matches.forEach(match => {
                entities.push({ text: match, type: pattern.type, color: pattern.color });
                processedText = processedText.replace(match, 
                    `<span style="background-color: ${pattern.color}; padding: 2px 4px; border-radius: 3px; color: white; font-weight: bold;">${match} (${pattern.type})</span>`
                );
            });
        }
    });
    
    let result = `<strong>Named Entities Found:</strong><br><br>`;
    result += processedText + '<br><br>';
    
    if (entities.length > 0) {
        result += '<strong>Entity List:</strong><br>';
        entities.forEach(entity => {
            result += `‚Ä¢ <span style="color: ${entity.color}; font-weight: bold;">${entity.text}</span> - ${entity.type}<br>`;
        });
    } else {
        result += '<em>No named entities detected with current patterns.</em>';
    }
    
    output.innerHTML = result;
}

function answerQuestion() {
    const context = document.getElementById('qaContext').value;
    const question = document.getElementById('qaQuestion').value;
    const output = document.getElementById('qaOutput');
    
    // Simple keyword-based question answering simulation
    const contextLower = context.toLowerCase();
    const questionLower = question.toLowerCase();
    
    let answer = "I couldn't find a specific answer in the context.";
    
    // Simple pattern matching for demo
    if (questionLower.includes('when') && questionLower.includes('introduced')) {
        const yearMatch = context.match(/\b(19|20)\d{2}\b/);
        if (yearMatch) {
            answer = `The Transformer model was introduced in ${yearMatch[0]}.`;
        }
    } else if (questionLower.includes('what') && questionLower.includes('transformer')) {
        const sentences = context.split(/[.!?]+/);
        const relevantSentence = sentences.find(s => s.toLowerCase().includes('transformer'));
        if (relevantSentence) {
            answer = relevantSentence.trim() + '.';
        }
    } else if (questionLower.includes('used for') || questionLower.includes('tasks')) {
        const tasks = context.match(/(?:tasks such as|for tasks|including) ([^.]+)/i);
        if (tasks) {
            answer = `Transformers are used for ${tasks[1]}.`;
        }
    }
    
    output.innerHTML = `
        <strong>Question:</strong> ${question}<br>
        <strong>Answer:</strong> ${answer}<br><br>
        <em>Note: This is a simplified keyword-based QA system for demonstration.</em>
    `;
}

function checkAnswer(element, isCorrect) {
    // Store original text if not already stored
    if (!element.dataset.originalText) {
        element.dataset.originalText = element.textContent.trim();
    }
    
    // Remove previous selections and reset text
    element.parentNode.querySelectorAll('.quiz-option').forEach(option => {
        option.classList.remove('correct', 'incorrect');
        if (option.dataset.originalText) {
            option.textContent = option.dataset.originalText;
        }
    });
    
    // Mark the selected answer
    if (isCorrect) {
        element.classList.add('correct');
        element.textContent = element.dataset.originalText + ' ‚úÖ Correct!';
    } else {
        element.classList.add('incorrect');
        element.textContent = element.dataset.originalText + ' ‚ùå Incorrect';
        
        // Show correct answer
        const correctOption = Array.from(element.parentNode.querySelectorAll('.quiz-option'))
            .find(option => {
                const onclickStr = option.getAttribute('onclick') || '';
                return onclickStr.includes('true');
            });
        if (correctOption) {
            correctOption.classList.add('correct');
            correctOption.textContent = correctOption.dataset.originalText + ' ‚úÖ Correct Answer';
        }
    }
}

// Initialize quiz options on page load
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.quiz-option').forEach(option => {
        option.dataset.originalText = option.textContent.trim();
    });
    
    // Add keyboard navigation
    document.addEventListener('keydown', function(e) {
        if (e.key === 'ArrowRight') {
            const currentIndex = sections.indexOf(currentSection);
            if (currentIndex < sections.length - 1) {
                const nextSection = sections[currentIndex + 1];
                showSection(nextSection);
                document.querySelector(`button[onclick="showSection('${nextSection}')"]`).classList.add('active');
            }
        } else if (e.key === 'ArrowLeft') {
            const currentIndex = sections.indexOf(currentSection);
            if (currentIndex > 0) {
                const prevSection = sections[currentIndex - 1];
                showSection(prevSection);
                document.querySelector(`button[onclick="showSection('${prevSection}')"]`).classList.add('active');
            }
        }
    });
    
    // Add Enter key support for demo inputs
    const demoInputs = document.querySelectorAll('.demo-input');
    demoInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const button = this.parentNode.querySelector('.demo-btn');
                if (button) button.click();
            }
        });
    });
});
</script>
{% endblock %}