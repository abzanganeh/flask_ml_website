<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 2: Agent Architecture Components - Agentic AI & LLM Agents</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/tutorials/agentic-ai/agentic-ai.css') }}">
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <!-- Prism.js for code syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
</head>
<body>
    <header class="azbn-header">
        <nav class="azbn-nav">
            <div class="azbn-container">
                <a href="/tutorials/agentic-ai" class="course-link">
                    <span>Agentic AI & LLM Agents</span>
                </a>
                <div class="azbn-links">
                    <a href="/">Home</a>
                    <a href="/#about">About</a>
                    <a href="/tutorials/">Tutorials</a>
                    <a href="/#projects">Projects</a>
                    <a href="/contact">Contact</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        <div class="tutorial-header">
            <div class="azbn-container">
                <h1 class="chapter-title">Chapter 2: Agent Architecture Components</h1>
                <p class="chapter-subtitle">Building Blocks of Agents</p>
                
                <div class="chapter-progress">
                    <div class="chapter-progress-fill" data-progress="25"></div>
                </div>
                
                <div class="chapter-navigation">
                    <a href="/tutorials/agentic-ai/chapter1" class="chapter-nav-btn ">Chapter 1</a>
                    <a href="/tutorials/agentic-ai/chapter2" class="chapter-nav-btn active">Chapter 2</a>
                    <a href="/tutorials/agentic-ai/chapter3" class="chapter-nav-btn ">Chapter 3</a>
                    <a href="/tutorials/agentic-ai/chapter4" class="chapter-nav-btn ">Chapter 4</a>
                    <a href="/tutorials/agentic-ai/chapter5" class="chapter-nav-btn ">Chapter 5</a>
                    <a href="/tutorials/agentic-ai/chapter6" class="chapter-nav-btn ">Chapter 6</a>
                    <a href="/tutorials/agentic-ai/chapter7" class="chapter-nav-btn ">Chapter 7</a>
                    <a href="/tutorials/agentic-ai/chapter8" class="chapter-nav-btn ">Chapter 8</a>
                </div>
                
                <div class="section-progress">
                    <div class="section-progress-fill" data-progress="14.3"></div>
                </div>
                
                <div class="section-nav">
                    <button class="section-nav-btn azbn-btn active" data-section="overview">Overview</button>
                    <button class="section-nav-btn azbn-btn" data-section="concepts">Key Concepts</button>
                    <button class="section-nav-btn azbn-btn" data-section="formulas">Formulas</button>
                    <button class="section-nav-btn azbn-btn" data-section="examples">Examples</button>
                    <button class="section-nav-btn azbn-btn" data-section="implementation">Implementation</button>
                    <button class="section-nav-btn azbn-btn" data-section="applications">Applications</button>
                    <button class="section-nav-btn azbn-btn" data-section="quiz">Quiz</button>
                </div>
            </div>
        </div>

        <section class="azbn-section">
            <div class="azbn-container">
                <div class="learning-objectives-box">
                    <h2>Learning Objectives</h2>
                    <ul>
                        <li>Understand agent architecture components fundamentals</li>
                        <li>Master the mathematical foundations</li>
                        <li>Learn practical implementation</li>
                        <li>Apply knowledge through examples</li>
                        <li>Recognize real-world applications</li>
                    </ul>
                </div>

                <main class="chapter-main-content">
                    <div id="overview" class="content-section active">
                        <h2>Agent Architecture Components</h2>
                        
                        <div class="explanation-box">
                            <h3>üéØ The Building Blocks</h3>
                            <p><strong>Every AI agent is built from five core components that work together to enable autonomous behavior.</strong> Understanding these components is essential for building effective agents.</p>
                            
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border: 2px solid #0ea5e9; border-radius: 12px; padding: 2rem; margin: 2rem 0;">
                                <h4 style="color: #0c4a6e; margin-bottom: 1.5rem; text-align: center;">üèóÔ∏è Agent Architecture Components Diagram</h4>
                                
                                <div style="background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem; margin-bottom: 1.5rem;">
                                        <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 8px; padding: 1.5rem; text-align: center;">
                                            <div style="font-size: 2.5rem; margin-bottom: 0.5rem;">üß†</div>
                                            <p style="font-weight: 700; color: #166534; margin: 0 0 0.5rem 0;">LLM Core</p>
                                            <p style="font-size: 0.85rem; color: #166534; margin: 0;">Reasoning engine</p>
                                        </div>
                                        
                                        <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 1.5rem; text-align: center;">
                                            <div style="font-size: 2.5rem; margin-bottom: 0.5rem;">üíæ</div>
                                            <p style="font-weight: 700; color: #92400e; margin: 0 0 0.5rem 0;">Memory System</p>
                                            <p style="font-size: 0.85rem; color: #92400e; margin: 0;">Short & long-term</p>
                                        </div>
                                        
                                        <div style="background: #fee2e2; border: 2px solid #ef4444; border-radius: 8px; padding: 1.5rem; text-align: center;">
                                            <div style="font-size: 2.5rem; margin-bottom: 0.5rem;">üîß</div>
                                            <p style="font-weight: 700; color: #991b1b; margin: 0 0 0.5rem 0;">Tool Interface</p>
                                            <p style="font-size: 0.85rem; color: #991b1b; margin: 0;">Function calling</p>
                                        </div>
                                        
                                        <div style="background: #e0e7ff; border: 2px solid #6366f1; border-radius: 8px; padding: 1.5rem; text-align: center;">
                                            <div style="font-size: 2.5rem; margin-bottom: 0.5rem;">üìã</div>
                                            <p style="font-weight: 700; color: #4338ca; margin: 0 0 0.5rem 0;">Planner</p>
                                            <p style="font-size: 0.85rem; color: #4338ca; margin: 0;">Task breakdown</p>
                                        </div>
                                    </div>
                                    
                                    <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 8px; padding: 1.5rem; text-align: center;">
                                        <div style="font-size: 2.5rem; margin-bottom: 0.5rem;">‚ö°</div>
                                        <p style="font-weight: 700; color: #166534; margin: 0 0 0.5rem 0;">Action Executor</p>
                                        <p style="font-size: 0.85rem; color: #166534; margin: 0;">Execute & observe</p>
                                    </div>
                                    
                                    <div style="background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 1rem; margin-top: 1.5rem; border-radius: 4px;">
                                        <p style="margin: 0; color: #0c4a6e; font-size: 0.9rem;"><strong>Key:</strong> All components work together. LLM reasons using memory, planner creates strategy, tool interface executes actions, executor observes results!</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h4>üîÑ Component Interactions</h4>
                            <p><strong>How components work together:</strong></p>
                            <ol>
                                <li><strong>LLM Core</strong> receives input and uses <strong>Memory</strong> for context</li>
                                <li><strong>Planner</strong> breaks down task into steps using LLM reasoning</li>
                                <li><strong>Tool Interface</strong> selects and calls appropriate tools</li>
                                <li><strong>Action Executor</strong> executes actions and observes results</li>
                                <li>Results update <strong>Memory</strong>, and the cycle continues</li>
                            </ol>
                        </div>
                    </div>

                    <div id="concepts" class="content-section">
                        <h2>Key Concepts</h2>
                        
                        <div class="explanation-box">
                            <h3>üîë Component 1: LLM as Reasoning Engine</h3>
                            <p><strong>The LLM is the "brain" of the agent - it processes information, reasons about tasks, and makes decisions.</strong></p>
                            
                            <div class="example-box">
                                <h4>What the LLM Does</h4>
                                <ul>
                                    <li><strong>Understanding:</strong> Interprets user requests and context</li>
                                    <li><strong>Reasoning:</strong> Thinks through problems step by step</li>
                                    <li><strong>Decision Making:</strong> Chooses what action to take next</li>
                                    <li><strong>Planning:</strong> Breaks down complex tasks into steps</li>
                                </ul>
                            </div>
                            
                            <div class="example-box">
                                <h4>Example: LLM Reasoning Process</h4>
                                <p><strong>User:</strong> "Research quantum computing and write a summary"</p>
                                <p><strong>LLM thinks:</strong></p>
                                <ol>
                                    <li>"I need to search for information about quantum computing"</li>
                                    <li>"Then I need to read and extract key points"</li>
                                    <li>"Finally, I need to write a summary"</li>
                                </ol>
                                <p><strong>Output:</strong> Plan with 3 steps</p>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h3>Component 2: Memory System</h3>
                            <p><strong>Memory allows agents to remember past interactions and maintain context across conversations.</strong></p>
                            
                            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 12px; padding: 2rem; margin: 1.5rem 0;">
                                <h4 style="color: #92400e; margin-bottom: 1.5rem; text-align: center;">Memory System Architecture</h4>
                                
                                <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem;">
                                        <div style="background: #dbeafe; border: 2px solid #3b82f6; border-radius: 8px; padding: 1.5rem;">
                                            <p style="font-weight: 700; color: #1e40af; margin: 0 0 0.5rem 0;">Short-Term Memory</p>
                                            <ul style="color: #1e40af; margin: 0; padding-left: 1.5rem; font-size: 0.9rem;">
                                                <li>Current conversation</li>
                                                <li>Recent actions</li>
                                                <li>Immediate context</li>
                                                <li>Last 10-20 turns</li>
                                            </ul>
                                        </div>
                                        
                                        <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 8px; padding: 1.5rem;">
                                            <p style="font-weight: 700; color: #166534; margin: 0 0 0.5rem 0;">Long-Term Memory</p>
                                            <ul style="color: #166534; margin: 0; padding-left: 1.5rem; font-size: 0.9rem;">
                                                <li>User preferences</li>
                                                <li>Important facts</li>
                                                <li>Past learnings</li>
                                                <li>Persistent storage</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="example-box">
                                <h4>Memory Example</h4>
                                <p><strong>Conversation 1:</strong></p>
                                <ul>
                                    <li>User: "I prefer meetings in the morning"</li>
                                    <li>Agent stores in long-term memory: {"preference": "morning_meetings"}</li>
                                </ul>
                                
                                <p><strong>Conversation 2 (weeks later):</strong></p>
                                <ul>
                                    <li>User: "Schedule a meeting"</li>
                                    <li>Agent retrieves preference ‚Üí Schedules for morning</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h3>Component 3: Tool Interface</h3>
                            <p><strong>The tool interface allows agents to interact with external systems and APIs.</strong></p>
                            
                            <div class="example-box">
                                <h4>How Tool Interface Works</h4>
                                <ol>
                                    <li><strong>Tool Definition:</strong> Each tool has a name, description, and parameters</li>
                                    <li><strong>Tool Selection:</strong> LLM decides which tool to use based on task</li>
                                    <li><strong>Tool Execution:</strong> Agent calls the tool with appropriate parameters</li>
                                    <li><strong>Result Integration:</strong> Tool results are fed back to LLM for further reasoning</li>
                                </ol>
                            </div>
                            
                            <div style="background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); border: 2px solid #ef4444; border-radius: 12px; padding: 2rem; margin: 1.5rem 0;">
                                <h4 style="color: #991b1b; margin-bottom: 1.5rem; text-align: center;">Tool Interface Flow</h4>
                                
                                <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 1rem;">
                                        <div style="text-align: center; flex: 1; min-width: 120px;">
                                            <div style="background: #dbeafe; border: 2px solid #3b82f6; border-radius: 8px; padding: 1rem;">
                                                <p style="font-weight: 700; color: #1e40af; margin: 0; font-size: 0.9rem;">LLM Decision</p>
                                                <p style="font-size: 0.8rem; color: #1e40af; margin: 0.3rem 0 0 0;">"Use weather API"</p>
                                            </div>
                                        </div>
                                        
                                        <div style="font-size: 1.5rem; color: #ef4444; font-weight: bold;">‚Üí</div>
                                        
                                        <div style="text-align: center; flex: 1; min-width: 120px;">
                                            <div style="background: #fee2e2; border: 2px solid #ef4444; border-radius: 8px; padding: 1rem;">
                                                <p style="font-weight: 700; color: #991b1b; margin: 0; font-size: 0.9rem;">Tool Selection</p>
                                                <p style="font-size: 0.8rem; color: #991b1b; margin: 0.3rem 0 0 0;">get_weather()</p>
                                            </div>
                                        </div>
                                        
                                        <div style="font-size: 1.5rem; color: #ef4444; font-weight: bold;">‚Üí</div>
                                        
                                        <div style="text-align: center; flex: 1; min-width: 120px;">
                                            <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 8px; padding: 1rem;">
                                                <p style="font-weight: 700; color: #166534; margin: 0; font-size: 0.9rem;">Execute</p>
                                                <p style="font-size: 0.8rem; color: #166534; margin: 0.3rem 0 0 0;">Call API</p>
                                            </div>
                                        </div>
                                        
                                        <div style="font-size: 1.5rem; color: #ef4444; font-weight: bold;">‚Üí</div>
                                        
                                        <div style="text-align: center; flex: 1; min-width: 120px;">
                                            <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 1rem;">
                                                <p style="font-weight: 700; color: #92400e; margin: 0; font-size: 0.9rem;">Result</p>
                                                <p style="font-size: 0.8rem; color: #92400e; margin: 0.3rem 0 0 0;">72¬∞F, sunny</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h3>Component 4: Planner</h3>
                            <p><strong>The planner breaks down complex tasks into manageable steps.</strong></p>
                            
                            <div class="example-box">
                                <h4>Planning Process</h4>
                                <p><strong>Task:</strong> "Research AI trends and create a presentation"</p>
                                <p><strong>Planner creates:</strong></p>
                                <ol>
                                    <li>Search for "AI trends 2024"</li>
                                    <li>Read and extract key points from articles</li>
                                    <li>Organize information into categories</li>
                                    <li>Create presentation slides</li>
                                    <li>Review and refine presentation</li>
                                </ol>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h3>Component 5: Action Executor</h3>
                            <p><strong>The executor carries out actions and observes results.</strong></p>
                            
                            <div class="example-box">
                                <h4>Execution Process</h4>
                                <ul>
                                    <li><strong>Execute:</strong> Runs the selected action (tool call, API request, etc.)</li>
                                    <li><strong>Observe:</strong> Captures the result or outcome</li>
                                    <li><strong>Validate:</strong> Checks if action succeeded</li>
                                    <li><strong>Update State:</strong> Updates agent state with new information</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div id="formulas" class="content-section">
                        <h2>Mathematical Formulations</h2>
                        
                        <div class="formula-box">
                            <h4>Agent State Representation</h4>
                            
                            <div class="formula-display">
                                \[\text{state} = (M, T, G, H)\]
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>What This Measures</h5>
                                <p><strong>This formula represents the complete internal state of an AI agent at any given moment.</strong> It captures all the information the agent needs to make decisions: what it remembers, what it can do, what it's trying to achieve, and what it has done. This state representation is the foundation for agent decision-making.</p>
                                
                                <h5>Breaking It Down</h5>
                                <ul>
                                    <li><strong>M (Memory):</strong> Memory system containing both short-term (recent conversation turns, immediate context buffer) and long-term (persistent facts, learned patterns, user preferences stored in vector databases or knowledge graphs). Memory enables the agent to maintain context across interactions and learn from experience.</li>
                                    <li><strong>T (Tools):</strong> Available tools - the set of functions, APIs, or capabilities the agent can use to interact with external systems. This includes tool definitions, descriptions, parameters, and execution functions. Tools extend the agent's capabilities beyond text generation.</li>
                                    <li><strong>G (Goal):</strong> Current goal or task - the objective the agent is trying to achieve. This guides all decision-making and helps the agent determine when a task is complete. Goals can be high-level (e.g., "answer user's question") or specific (e.g., "get weather for New York").</li>
                                    <li><strong>H (History):</strong> History of actions - a record of what the agent has done, including past actions, their results, and the sequence of decisions. History helps the agent avoid repeating mistakes, track progress, and understand the context of the current situation.</li>
                                </ul>
                                
                                <h5>Where This Is Used</h5>
                                <p>This state representation is used throughout the agent's operation. It's passed to the decision function to determine the next action, updated after each action based on observations, stored persistently for long-term memory, and used to track progress toward goals. The state is the agent's "memory" of its current situation and past experiences.</p>
                                
                                <h5>Why This Matters</h5>
                                <p>A comprehensive state representation is essential for intelligent agent behavior. Without proper state tracking, agents cannot maintain context, learn from experience, or make informed decisions. This formula ensures all critical information (memory, capabilities, objectives, history) is captured and available for decision-making, enabling agents to operate autonomously and adaptively.</p>
                                
                                <div class="example-box">
                                    <h5>Example Calculation</h5>
                                    <p><strong>Given:</strong> An agent helping a user with research</p>
                                    <ul>
                                        <li>M = {"short_term": ["User asked about quantum computing"], "long_term": {"user_interests": ["AI", "physics"], "preferred_format": "detailed"}}</li>
                                        <li>T = ["search_web", "read_document", "summarize", "write_report"]</li>
                                        <li>G = "Research quantum computing and provide detailed summary"</li>
                                        <li>H = [{"action": "search_web", "query": "quantum computing 2024", "result": "found 5 articles"}]</li>
                                    </ul>
                                    <p><strong>State:</strong> state = (M, T, G, H)</p>
                                    <p><strong>Interpretation:</strong> The agent knows the user's interests and preferences (from M), has access to research tools (T), is working toward providing a detailed quantum computing summary (G), and has already searched the web (H). This complete state enables the agent to make informed next decisions, such as reading the found articles or generating the summary.</p>
                                </div>
                            </div>
                        </div>

                        <div class="formula-box">
                            <h4>Tool Selection Function</h4>
                            
                            <div class="formula-display">
                                \[t^* = \underset{t \in T}{\arg\max} P(\text{tool} = t \mid \text{state}, \text{goal})\]
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>What This Measures</h5>
                                <p><strong>This function determines which tool the agent should use from its available toolset.</strong> It calculates the probability that each tool is appropriate given the current state and goal, then selects the tool with the highest probability. This enables intelligent tool selection based on context rather than random or fixed choices.</p>
                                
                                <h5>Breaking It Down</h5>
                                <ul>
                                    <li><strong>T:</strong> Set of available tools - all functions, APIs, or capabilities the agent can use (e.g., ["get_weather", "search_web", "calculate", "send_email"]). The agent evaluates each tool in this set.</li>
                                    <li><strong>state:</strong> Current agent state - includes memory, history, current observations, and any relevant context. The state provides information about what the agent knows and what situation it's in.</li>
                                    <li><strong>goal:</strong> Current goal - the objective the agent is trying to achieve. The goal helps determine which tool would be most useful (e.g., if goal is "get weather", weather tools have higher probability).</li>
                                    <li><strong>P(tool = t | state, goal):</strong> Probability that tool t is appropriate given the state and goal. This is typically calculated using LLM reasoning (the LLM evaluates tool descriptions against the current context) or learned models. Higher probability means the tool is more likely to help achieve the goal.</li>
                                    <li><strong>t^*:</strong> Selected tool - the tool with maximum probability. This is the optimal tool choice that maximizes the likelihood of successfully completing the goal.</li>
                                </ul>
                                
                                <h5>Where This Is Used</h5>
                                <p>This function is called during the "Reason" step of the agent loop when the agent determines it needs to use a tool. The agent evaluates all available tools, calculates their appropriateness probabilities, and selects the best one. This happens before tool execution, ensuring the agent uses the most suitable tool for the current situation.</p>
                                
                                <h5>Why This Matters</h5>
                                <p>Intelligent tool selection is crucial for agent effectiveness. Using the wrong tool wastes resources and fails to achieve goals, while using the right tool efficiently accomplishes tasks. This formula enables agents to make context-aware tool choices rather than random selection, dramatically improving success rates and efficiency. Without proper tool selection, agents would either use tools inappropriately or need to try multiple tools, leading to wasted resources and poor performance.</p>
                                
                                <div class="example-box">
                                    <h5>Example Calculation</h5>
                                    <p><strong>Given:</strong></p>
                                    <ul>
                                        <li>T = ["get_weather", "search_web", "calculate", "send_email"]</li>
                                        <li>state = "User asked: 'What's the weather in New York?'"</li>
                                        <li>goal = "Provide accurate weather information"</li>
                                    </ul>
                                    <p><strong>Step 1:</strong> Calculate P(tool | state, goal) for each tool:</p>
                                    <ul>
                                        <li>P(get_weather | state, goal) = 0.95 (very high - directly relevant)</li>
                                        <li>P(search_web | state, goal) = 0.3 (moderate - could work but less direct)</li>
                                        <li>P(calculate | state, goal) = 0.05 (very low - not relevant)</li>
                                        <li>P(send_email | state, goal) = 0.02 (very low - not relevant)</li>
                                    </ul>
                                    <p><strong>Step 2:</strong> Find maximum: max P = 0.95</p>
                                    <p><strong>Result:</strong> t^* = get_weather (tool with P = 0.95)</p>
                                    <p><strong>Interpretation:</strong> The agent correctly identified that get_weather is the most appropriate tool for answering a weather question. The high probability (0.95) reflects that this tool directly matches the user's request and the agent's goal. This demonstrates how the tool selection function enables context-aware decision-making.</p>
                                </div>
                            </div>
                        </div>

                        <div class="formula-box">
                            <h4>Memory Update Function</h4>
                            
                            <div class="formula-display">
                                \[M_{t+1} = \text{Update}(M_t, \text{action}_t, \text{observation}_t, \text{importance})\]
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>What This Measures</h5>
                                <p><strong>This function describes how the agent's memory system evolves over time.</strong> It takes the current memory, the action that was taken, the observation that resulted, and an importance score, then updates the memory accordingly. This enables agents to learn from experience and maintain relevant information for future decisions.</p>
                                
                                <h5>Breaking It Down</h5>
                                <ul>
                                    <li><strong>M_t:</strong> Memory at time t - the current state of the agent's memory system, including short-term buffer (recent conversation turns, immediate context) and long-term store (persistent facts, learned patterns, important information). This is the agent's knowledge base before the update.</li>
                                    <li><strong>action_t:</strong> Action taken at time t - the specific action the agent executed (e.g., called a tool, generated text, asked a question). The action provides context about what the agent was trying to do.</li>
                                    <li><strong>observation_t:</strong> Result observed from the action - what happened as a result (tool output, user response, error, environmental change). Observations are the new information that needs to be incorporated into memory.</li>
                                    <li><strong>importance:</strong> How important the information is to remember - a score (typically 0-1) that determines whether information goes to short-term memory (low importance, temporary) or long-term memory (high importance, persistent). Importance can be determined by: user explicitly marking as important, agent reasoning about relevance, frequency of similar information, or success/failure of actions.</li>
                                    <li><strong>M_{t+1}:</strong> Updated memory after incorporating the new information. The Update function: adds observation to short-term buffer, evaluates importance to decide if it should be stored long-term, updates existing memories if new information contradicts or enhances them, and manages memory capacity (may remove low-importance old information).</li>
                                </ul>
                                
                                <h5>Where This Is Used</h5>
                                <p>This update happens after every action in the agent loop, specifically after observing the result of an action. The memory update is a critical step that ensures the agent learns from experience. It's used to: maintain conversation context (short-term), store important facts for future use (long-term), update beliefs when new information contradicts old information, and manage memory capacity by prioritizing important information.</p>
                                
                                <h5>Why This Matters</h5>
                                <p>Effective memory updates are essential for agent learning and adaptation. Without proper memory updates, agents cannot learn from experience, maintain context across conversations, or adapt their behavior based on outcomes. This function enables agents to: remember user preferences, learn from successful and failed actions, maintain conversation context, and build a knowledge base over time. This is what makes agents "intelligent" rather than just reactive - they learn and improve.</p>
                                
                                <div class="example-box">
                                    <h5>Example Calculation</h5>
                                    <p><strong>Given:</strong></p>
                                    <ul>
                                        <li>M_t = {"short_term": ["User asked about weather"], "long_term": {"user_preference": "Celsius"}}</li>
                                        <li>action_t = "call get_weather(city='New York')"</li>
                                        <li>observation_t = {"temp": 22, "condition": "sunny", "date": "2024-12-10"}</li>
                                        <li>importance = 0.3 (moderate - weather data is useful but time-sensitive)</li>
                                    </ul>
                                    <p><strong>Step 1:</strong> Add observation to short-term memory (always done for recent context)</p>
                                    <p><strong>Step 2:</strong> Evaluate importance (0.3) ‚Üí below threshold (0.5) ‚Üí store in short-term only</p>
                                    <p><strong>Step 3:</strong> Update short-term: add weather data, keep last 10 turns</p>
                                    <p><strong>Step 4:</strong> Long-term memory unchanged (importance too low)</p>
                                    <p><strong>Result:</strong> M_{t+1} = {"short_term": ["User asked about weather", "Weather: 22¬∞C sunny on 2024-12-10"], "long_term": {"user_preference": "Celsius"}}</p>
                                    <p><strong>Interpretation:</strong> The weather data was added to short-term memory (for current conversation context) but not to long-term memory (because it's time-sensitive and will be outdated soon). The user preference remains in long-term memory as it's still relevant. This demonstrates how importance scores guide memory storage decisions, ensuring important information persists while temporary data is kept only for immediate context.</p>
                                </div>
                            </div>
                        </div>

                        <div class="formula-box">
                            <h4>Planning Function</h4>
                            
                            <div class="formula-display">
                                \[\text{plan} = \text{Planner}(\text{goal}, \text{state}, \text{constraints})\]
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>What This Measures</h5>
                                <p><strong>This function generates a sequence of actions (a plan) to achieve a goal.</strong> It takes the desired outcome, current state, and any constraints, then produces an ordered sequence of actions that, when executed, should accomplish the goal. This enables agents to handle complex, multi-step tasks by breaking them down into manageable steps.</p>
                                
                                <h5>Breaking It Down</h5>
                                <ul>
                                    <li><strong>goal:</strong> Desired outcome - the objective the agent wants to achieve (e.g., "Research quantum computing and write a summary", "Help user book a flight"). The goal defines what success looks like and guides the planning process.</li>
                                    <li><strong>state:</strong> Current state - the agent's current understanding including memory, available tools, and current situation. The state tells the planner what resources and information are available, and what the starting point is.</li>
                                    <li><strong>constraints:</strong> Limitations that must be considered - time limits, resource constraints (API rate limits, token budgets), dependencies between actions, safety requirements, or user preferences. Constraints ensure the plan is feasible and acceptable.</li>
                                    <li><strong>plan:</strong> Sequence of actions [action_1, action_2, ..., action_n] - an ordered list of steps to execute. Each action in the sequence builds on previous actions, with later actions depending on results from earlier ones. The plan provides a roadmap from current state to goal.</li>
                                </ul>
                                
                                <h5>Where This Is Used</h5>
                                <p>This function is called when the agent receives a complex goal that requires multiple steps. The planner analyzes the goal, evaluates the current state, considers constraints, and generates a step-by-step plan. The plan is then executed sequentially, with the agent following each step and adapting if needed. Planning typically happens at the start of a task, though plans can be revised if circumstances change.</p>
                                
                                <h5>Why This Matters</h5>
                                <p>Planning enables agents to handle complex tasks that require multiple coordinated actions. Without planning, agents would make decisions reactively, one step at a time, without considering the full path to the goal. This leads to inefficient behavior, missed dependencies, and failure on complex tasks. Planning allows agents to: break down complex goals into manageable steps, identify dependencies between actions, optimize the sequence of actions, and anticipate potential issues. This is what distinguishes planning agents from simple reactive agents.</p>
                                
                                <div class="example-box">
                                    <h5>Example Calculation</h5>
                                    <p><strong>Given:</strong></p>
                                    <ul>
                                        <li>goal = "Research quantum computing developments in 2024 and write a 500-word summary"</li>
                                        <li>state = {"memory": ["User interested in AI"], "tools": ["search_web", "read_document", "summarize", "write"]}</li>
                                        <li>constraints = {"max_steps": 10, "time_limit": 5 minutes, "token_budget": 10000}</li>
                                    </ul>
                                    <p><strong>Step 1:</strong> Planner analyzes goal ‚Üí needs research, reading, and writing</p>
                                    <p><strong>Step 2:</strong> Planner checks state ‚Üí has necessary tools available</p>
                                    <p><strong>Step 3:</strong> Planner considers constraints ‚Üí must complete in 10 steps, 5 minutes</p>
                                    <p><strong>Step 4:</strong> Planner generates sequence:</p>
                                    <ul>
                                        <li>action_1 = "search_web(query='quantum computing 2024')"</li>
                                        <li>action_2 = "read_document(articles from search)"</li>
                                        <li>action_3 = "extract_key_points(documents)"</li>
                                        <li>action_4 = "write_summary(key_points, length=500_words)"</li>
                                    </ul>
                                    <p><strong>Result:</strong> plan = [search_web, read_document, extract_key_points, write_summary]</p>
                                    <p><strong>Interpretation:</strong> The planner broke down the complex goal into 4 sequential steps: first search for information, then read the found documents, extract important points, and finally write the summary. The plan respects constraints (4 steps < 10 max, estimated time < 5 minutes) and follows logical dependencies (can't write before reading, can't read before searching). This demonstrates how planning enables systematic approach to complex tasks.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="examples" class="content-section">
                        <h2>Detailed Examples</h2>
                        
                        <div class="example-box">
                            <h4>Example 1: Email Agent - Component Interaction</h4>
                            <p><strong>Task: "Check my emails and summarize important ones"</strong></p>
                            
                            <p>This example demonstrates how all agent components work together to complete a complex task. The agent must coordinate between its reasoning engine, memory system, planning module, tool interface, and action executor to successfully retrieve and summarize emails.</p>
                            
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border: 2px solid #0ea5e9; border-radius: 12px; padding: 2rem; margin: 1.5rem 0;">
                                <h4 style="color: #0c4a6e; margin-bottom: 1.5rem; text-align: center;">Component Interaction Flow</h4>
                                
                                <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                    <div style="margin-bottom: 1.5rem;">
                                        <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 1rem; border-radius: 4px; margin-bottom: 0.5rem;">
                                            <p style="font-weight: 700; color: #1e40af; margin: 0 0 0.3rem 0;">LLM Core</p>
                                            <p style="color: #1e40af; margin: 0; font-size: 0.9rem;">Receives: "Check emails and summarize important ones"</p>
                                            <p style="color: #1e40af; margin: 0.3rem 0 0 0; font-size: 0.9rem;">Uses Memory: Retrieves email preferences</p>
                                        </div>
                                        
                                        <div style="background: #e0e7ff; border-left: 4px solid #6366f1; padding: 1rem; border-radius: 4px; margin-bottom: 0.5rem;">
                                            <p style="font-weight: 700; color: #4338ca; margin: 0 0 0.3rem 0;">Planner</p>
                                            <p style="color: #4338ca; margin: 0; font-size: 0.9rem;">Creates plan: 1) Fetch emails, 2) Filter important, 3) Summarize</p>
                                        </div>
                                        
                                        <div style="background: #fee2e2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 4px; margin-bottom: 0.5rem;">
                                            <p style="font-weight: 700; color: #991b1b; margin: 0 0 0.3rem 0;">Tool Interface</p>
                                            <p style="color: #991b1b; margin: 0; font-size: 0.9rem;">Selects: <code style="background: #fee2e2; padding: 0.2rem 0.4rem; border-radius: 3px;">fetch_emails()</code></p>
                                        </div>
                                        
                                        <div style="background: #f0fdf4; border-left: 4px solid #22c55e; padding: 1rem; border-radius: 4px; margin-bottom: 0.5rem;">
                                            <p style="font-weight: 700; color: #166534; margin: 0 0 0.3rem 0;">Action Executor</p>
                                            <p style="color: #166534; margin: 0; font-size: 0.9rem;">Executes: Calls email API, receives 20 emails</p>
                                        </div>
                                        
                                        <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 1rem; border-radius: 4px; margin-bottom: 0.5rem;">
                                            <p style="font-weight: 700; color: #92400e; margin: 0 0 0.3rem 0;">Memory</p>
                                            <p style="color: #92400e; margin: 0; font-size: 0.9rem;">Stores: Email count, important email IDs</p>
                                        </div>
                                        
                                        <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 1rem; border-radius: 4px;">
                                            <p style="font-weight: 700; color: #1e40af; margin: 0 0 0.3rem 0;">LLM Core (Again)</p>
                                            <p style="color: #1e40af; margin: 0; font-size: 0.9rem;">Summarizes important emails using retrieved data</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="example-box">
                            <h4>Example 2: Memory System in Action</h4>
                            <p><strong>Demonstrating short-term vs long-term memory:</strong></p>
                            
                            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 12px; padding: 2rem; margin: 1.5rem 0;">
                                <h4 style="color: #92400e; margin-bottom: 1.5rem; text-align: center;">Memory System Example</h4>
                                
                                <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                    <table style="width: 100%; border-collapse: collapse;">
                                        <thead>
                                            <tr style="background: #f3f4f6;">
                                                <th style="padding: 0.8rem; text-align: left; border: 1px solid #d1d5db; color: #374151; font-weight: 600;">Turn</th>
                                                <th style="padding: 0.8rem; text-align: left; border: 1px solid #d1d5db; color: #374151; font-weight: 600;">Short-Term Memory</th>
                                                <th style="padding: 0.8rem; text-align: left; border: 1px solid #d1d5db; color: #374151; font-weight: 600;">Long-Term Memory</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; font-weight: 600; color: #1e40af;">1</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; color: #374151;">User: "I'm John"</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; color: #166534;">Stored: name = "John"</td>
                                            </tr>
                                            <tr style="background: #f9fafb;">
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; font-weight: 600; color: #1e40af;">2</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; color: #374151;">User: "Schedule meeting"<br>Agent: Uses name from memory</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; color: #166534;">name = "John" (retrieved)</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; font-weight: 600; color: #1e40af;">3</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; color: #374151;">User: "What's my name?"<br>Agent: "John" (from long-term)</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; color: #166534;">name = "John" (persistent)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="implementation" class="content-section">
                        <h2>Implementation</h2>
                        
                        <div class="code-box">
                            <h4>Memory System Implementation</h4>
                            <pre><code class="language-python">from typing import Dict, List, Any
from datetime import datetime
import json

class MemorySystem:
    """Agent memory system with short-term and long-term storage"""
    
    def __init__(self):
        self.short_term = []  # Recent conversation (last N turns)
        self.long_term = {}   # Persistent facts and preferences
        self.max_short_term = 20  # Keep last 20 turns
    
    def add_to_short_term(self, role: str, content: str):
        """Add to short-term memory (conversation history)"""
        self.short_term.append({
            'role': role,  # 'user' or 'agent'
            'content': content,
            'timestamp': datetime.now().isoformat()
        })
        
        # Keep only recent turns
        if len(self.short_term) > self.max_short_term:
            self.short_term = self.short_term[-self.max_short_term:]
    
    def add_to_long_term(self, key: str, value: Any, importance: float = 0.5):
        """
        Add to long-term memory
        
        Parameters:
        key: Memory key (e.g., 'user_name', 'preference')
        value: Memory value
        importance: How important (0-1), affects retention
        """
        self.long_term[key] = {
            'value': value,
            'importance': importance,
            'timestamp': datetime.now().isoformat(),
            'access_count': 0
        }
    
    def retrieve_from_long_term(self, key: str) -> Any:
        """Retrieve from long-term memory"""
        if key in self.long_term:
            self.long_term[key]['access_count'] += 1
            return self.long_term[key]['value']
        return None
    
    def get_context(self, max_turns: int = 10) -> List[Dict]:
        """Get recent conversation context"""
        return self.short_term[-max_turns:]
    
    def search_long_term(self, query: str) -> List[Dict]:
        """Search long-term memory by key or value"""
        results = []
        query_lower = query.lower()
        
        for key, data in self.long_term.items():
            if query_lower in key.lower() or query_lower in str(data['value']).lower():
                results.append({'key': key, 'value': data['value']})
        
        return results

# Example usage
memory = MemorySystem()

# Add to short-term (conversation)
memory.add_to_short_term('user', "What's the weather?")
memory.add_to_short_term('agent', "I'll check the weather for you.")

# Add to long-term (preferences)
memory.add_to_long_term('user_name', 'John', importance=0.9)
memory.add_to_long_term('preferred_timezone', 'EST', importance=0.7)

# Retrieve context
context = memory.get_context(max_turns=5)
print("Context:", context)

# Retrieve from long-term
user_name = memory.retrieve_from_long_term('user_name')
print(f"User name: {user_name}")</code></pre>
                        </div>

                        <div class="code-box">
                            <h4>Tool Interface Implementation</h4>
                            <pre><code class="language-python">from typing import Dict, List, Callable, Any
import inspect

class ToolInterface:
    """Tool interface for agent tool management and execution"""
    
    def __init__(self):
        self.tools: Dict[str, Dict] = {}
    
    def register_tool(self, name: str, description: str, function: Callable, parameters: Dict):
        """
        Register a tool
        
        Parameters:
        name: Tool name
        description: What the tool does
        function: Python function to execute
        parameters: Parameter schema (name -> type)
        """
        self.tools[name] = {
            'name': name,
            'description': description,
            'function': function,
            'parameters': parameters
        }
    
    def list_tools(self) -> List[Dict]:
        """List all available tools with descriptions"""
        return [
            {
                'name': tool['name'],
                'description': tool['description'],
                'parameters': tool['parameters']
            }
            for tool in self.tools.values()
        ]
    
    def select_tool(self, task_description: str, llm) -> str:
        """
        Use LLM to select appropriate tool
        
        Parameters:
        task_description: What needs to be done
        llm: Language model for tool selection
        
        Returns:
        Selected tool name
        """
        available_tools = self.list_tools()
        
        prompt = f"""
        Task: {task_description}
        Available tools: {json.dumps(available_tools, indent=2)}
        
        Select the most appropriate tool. Return only the tool name.
        """
        
        selected = llm.generate(prompt).strip()
        return selected
    
    def execute_tool(self, tool_name: str, parameters: Dict) -> Any:
        """
        Execute a tool
        
        Parameters:
        tool_name: Name of tool to execute
        parameters: Parameters for the tool
        
        Returns:
        Tool execution result
        """
        if tool_name not in self.tools:
            raise ValueError(f"Tool {tool_name} not found")
        
        tool = self.tools[tool_name]
        func = tool['function']
        
        # Validate parameters
        sig = inspect.signature(func)
        required_params = list(sig.parameters.keys())
        
        # Call function with parameters
        try:
            result = func(**parameters)
            return {
                'success': True,
                'tool': tool_name,
                'result': result
            }
        except Exception as e:
            return {
                'success': False,
                'tool': tool_name,
                'error': str(e)
            }

# Example tools
def get_weather(city: str) -> str:
    """Get weather for a city"""
    # In real implementation, call weather API
    return f"Weather in {city}: 72¬∞F, sunny"

def calculate(expression: str) -> float:
    """Evaluate a mathematical expression"""
    try:
        return eval(expression)
    except:
        return "Invalid expression"

# Example usage
tool_interface = ToolInterface()

# Register tools
tool_interface.register_tool(
    name='get_weather',
    description='Get current weather for a city',
    function=get_weather,
    parameters={'city': 'string'}
)

tool_interface.register_tool(
    name='calculate',
    description='Calculate a mathematical expression',
    function=calculate,
    parameters={'expression': 'string'}
)

# List tools
tools = tool_interface.list_tools()
print("Available tools:", tools)

# Execute tool
result = tool_interface.execute_tool('get_weather', {'city': 'New York'})
print("Result:", result)</code></pre>
                        </div>

                        <div class="code-box">
                            <h4>Planner Implementation</h4>
                            <pre><code class="language-python">from typing import List, Dict, Any

class Planner:
    """Agent planner for breaking down tasks into steps"""
    
    def __init__(self, llm):
        self.llm = llm
    
    def create_plan(self, goal: str, available_tools: List[str], constraints: Dict = None) -> List[Dict]:
        """
        Create a plan to achieve goal
        
        Parameters:
        goal: The goal to achieve
        available_tools: List of available tool names
        constraints: Constraints (max_steps, time_limit, etc.)
        
        Returns:
        List of planned steps
        """
        constraints = constraints or {}
        max_steps = constraints.get('max_steps', 10)
        
        prompt = f"""
        Goal: {goal}
        Available tools: {', '.join(available_tools)}
        Maximum steps: {max_steps}
        
        Create a step-by-step plan to achieve this goal.
        Return a JSON array of steps, each with:
        - step_number: int
        - action: string (tool name or "reason")
        - description: string
        - parameters: dict (if using a tool)
        
        Example:
        [
            {% raw %}{{"step_number": 1, "action": "search_web", "description": "Search for information", "parameters": {"query": "..."}}},{% endraw %}
            {% raw %}{{"step_number": 2, "action": "reason", "description": "Analyze results", "parameters": {}}}{% endraw %}
        ]
        """
        
        plan_json = self.llm.generate(prompt)
        plan = json.loads(plan_json)
        
        return plan
    
    def refine_plan(self, current_plan: List[Dict], new_information: str) -> List[Dict]:
        """
        Refine plan based on new information
        
        Parameters:
        current_plan: Current plan steps
        new_information: New information that affects the plan
        
        Returns:
        Refined plan
        """
        prompt = f"""
        Current plan: {json.dumps(current_plan, indent=2)}
        New information: {new_information}
        
        Refine the plan based on this new information.
        Return the updated plan as JSON array.
        """
        
        refined_plan_json = self.llm.generate(prompt)
        refined_plan = json.loads(refined_plan_json)
        
        return refined_plan

# Example usage
# planner = Planner(llm=my_llm)
# plan = planner.create_plan(
#     goal="Research quantum computing and write summary",
#     available_tools=['search_web', 'read_document', 'write_document']
# )
# print("Plan:", plan)</code></pre>
                        </div>
                    </div>

                    <div id="applications" class="content-section">
                        <h2>Real-World Applications</h2>
                        
                        <div class="explanation-box">
                            <h3>üåç Component Usage in Real Systems</h3>
                            <p><strong>Each component is critical in production agent systems:</strong></p>
                            
                            <div class="example-box">
                                <h4>1. Customer Support Agents</h4>
                                <ul>
                                    <li><strong>LLM Core:</strong> Understands customer queries, generates responses</li>
                                    <li><strong>Memory:</strong> Remembers customer history, preferences, past issues</li>
                                    <li><strong>Tool Interface:</strong> Accesses order database, CRM system, knowledge base</li>
                                    <li><strong>Planner:</strong> Creates resolution steps (check order ‚Üí verify issue ‚Üí process refund)</li>
                                    <li><strong>Executor:</strong> Executes database queries, updates records</li>
                                </ul>
                            </div>
                            
                            <div class="example-box">
                                <h4>2. Research Agents</h4>
                                <ul>
                                    <li><strong>LLM Core:</strong> Analyzes research questions, synthesizes information</li>
                                    <li><strong>Memory:</strong> Stores research findings, source citations</li>
                                    <li><strong>Tool Interface:</strong> Uses web search, academic databases, PDF readers</li>
                                    <li><strong>Planner:</strong> Plans research strategy (search ‚Üí read ‚Üí extract ‚Üí synthesize)</li>
                                    <li><strong>Executor:</strong> Executes searches, processes documents</li>
                                </ul>
                            </div>
                            
                            <div class="example-box">
                                <h4>3. Code Generation Agents</h4>
                                <ul>
                                    <li><strong>LLM Core:</strong> Understands requirements, generates code</li>
                                    <li><strong>Memory:</strong> Remembers codebase patterns, user preferences</li>
                                    <li><strong>Tool Interface:</strong> Uses code editor, compiler, test runner, git</li>
                                    <li><strong>Planner:</strong> Plans development steps (design ‚Üí implement ‚Üí test ‚Üí refactor)</li>
                                    <li><strong>Executor:</strong> Writes files, runs tests, commits code</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h3>üìä Component Importance Matrix</h3>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #22c55e; border-radius: 12px; padding: 2rem; margin: 1.5rem 0;">
                                <h4 style="color: #14532d; margin-bottom: 1.5rem; text-align: center;">üìä Component Criticality by Agent Type</h4>
                                
                                <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                    <table style="width: 100%; border-collapse: collapse;">
                                        <thead>
                                            <tr style="background: #f3f4f6;">
                                                <th style="padding: 0.8rem; text-align: left; border: 1px solid #d1d5db; color: #374151; font-weight: 600;">Component</th>
                                                <th style="padding: 0.8rem; text-align: center; border: 1px solid #d1d5db; color: #374151; font-weight: 600;">Simple Agent</th>
                                                <th style="padding: 0.8rem; text-align: center; border: 1px solid #d1d5db; color: #374151; font-weight: 600;">Tool Agent</th>
                                                <th style="padding: 0.8rem; text-align: center; border: 1px solid #d1d5db; color: #374151; font-weight: 600;">Planning Agent</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; font-weight: 600; color: #374151;">LLM Core</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #166534; font-weight: 700;">Critical</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #166534; font-weight: 700;">Critical</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #166534; font-weight: 700;">Critical</td>
                                            </tr>
                                            <tr style="background: #f9fafb;">
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; font-weight: 600; color: #374151;">Memory</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #991b1b;">Optional</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #92400e; font-weight: 600;">Important</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #166534; font-weight: 700;">Critical</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; font-weight: 600; color: #374151;">Tool Interface</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #991b1b;">None</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #166534; font-weight: 700;">Critical</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #166534; font-weight: 700;">Critical</td>
                                            </tr>
                                            <tr style="background: #f9fafb;">
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; font-weight: 600; color: #374151;">Planner</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #991b1b;">None</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #991b1b;">Optional</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #166534; font-weight: 700;">Critical</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; font-weight: 600; color: #374151;">Executor</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #991b1b;">None</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #92400e; font-weight: 600;">Important</td>
                                                <td style="padding: 0.8rem; border: 1px solid #d1d5db; text-align: center; color: #166534; font-weight: 700;">Critical</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="quiz" class="content-section">
                        <h2>Test Your Understanding</h2>
                        
                        <div class="quiz-container">
                        <div class="quiz-question">
                                <h3>Question 1: What are the five core components of an AI agent?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) While the LLM provides the reasoning engine, a complete agent architecture integrates multiple components: the LLM for reasoning, memory systems for context retention, tool interfaces for external interactions, planning modules for task decomposition, and action executors for implementing decisions, all working in coordination</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Only the LLM</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">C) LLM Core, Memory System, Tool Interface, Planner, Action Executor</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) While the LLM is crucial, a complete agent architecture requires memory systems, tool interfaces, planning modules, and action executors working together</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 2: What is the difference between short-term and long-term memory in agents?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) Short-term is faster</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Short-term and long-term memory serve different purposes: short-term memory maintains recent conversation context and immediate state for the current interaction, while long-term memory stores persistent facts, learned patterns, user preferences, and important information that should be accessible across multiple sessions and conversations</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">C) Short-term stores recent conversation, long-term stores persistent facts and preferences</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Short-term memory provides immediate context for the current conversation, while long-term memory maintains important information across multiple sessions</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 3: What does the Tool Interface do?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Manages tool registration, selection, and execution for agent interactions with external systems</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) It stores memory</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) While text generation is handled by the LLM, the tool interface specifically manages registration, selection, and execution of external tools and APIs</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) The tool interface is specifically responsible for managing agent interactions with external systems: it registers available tools, provides tool descriptions to the LLM for selection, handles tool execution with proper parameter passing, manages error handling for tool failures, and integrates tool results back into the agent's reasoning process</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 4: Interview question: "How would you implement a memory system that can handle both recent context and long-term facts?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) While vector databases are excellent for storing and retrieving long-term memory embeddings, a complete agent memory system requires a short-term memory buffer for recent conversation context, a long-term memory store (vector database or knowledge graph) for persistent facts and learned information, and a retrieval mechanism to access relevant memories when needed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) While vector databases are useful for long-term memory, a complete memory system requires both short-term buffers for recent context and retrieval mechanisms</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">C) Use a short-term buffer (list/queue) for recent conversation turns, and a long-term store (vector DB, key-value store, or knowledge graph) for persistent facts with importance-based retention</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Just storing all conversations in a list</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 5: What is the role of the Planner component in an agent architecture?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) Memory storage is managed by the memory system, while the planner creates execution strategies and task sequences</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) It stores memory</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">C) To break down complex goals into sequences of actionable steps</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) The planner component is responsible for task decomposition and strategy creation: it breaks down complex goals into sequences of actionable steps, identifies dependencies between tasks, creates execution plans, adapts plans based on intermediate results, and coordinates multi-step task execution, while action execution itself is handled by the action executor component</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 6: In the formula t* = argmax P(tool = t | state, goal), what does this represent?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) While agents can process text faster in some scenarios, speed is not the fundamental difference between agents and traditional LLMs</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">B) The tool selection process where the agent chooses the tool that maximizes the probability of being appropriate given the current state and goal</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) There is no difference</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) While processing speed and model size can vary between implementations, the fundamental distinction between agents and traditional LLMs is their ability to autonomously use tools, access real-time data, make decisions, and take actions that affect the environment, not just generate text responses</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 7: Interview question: "How does the Action Executor differ from the Tool Interface?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Tool Interface manages tool registration and selection, while Action Executor handles the actual execution, observation, validation, and state updates</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) It plans tasks</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) The tool interface is specifically responsible for managing agent interactions with external systems: it registers available tools, provides tool descriptions to the LLM for selection, handles tool execution with proper parameter passing, manages error handling for tool failures, and integrates tool results back into the agent's reasoning process</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) While text generation is handled by the LLM, the tool interface specifically manages registration, selection, and execution of external tools and APIs</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 8: What does the memory update function M_{t+1} = Update(M_t, action_t, observation_t, importance) represent?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) Using only the LLM's context window</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) While vector databases are excellent for storing and retrieving long-term memory embeddings, a complete agent memory system requires a short-term memory buffer for recent conversation context, a long-term memory store (vector database or knowledge graph) for persistent facts and learned information, and a retrieval mechanism to access relevant memories when needed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Storing conversations in a list provides basic history but doesn't distinguish between short-term context and long-term persistent facts that need to be retrieved</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">D) How agent memory evolves over time based on actions taken, observations received, and the importance of information</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 9: Interview question: "When would you use a vector database vs a key-value store for long-term memory?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Vector database for semantic search and similarity-based retrieval, key-value store for exact lookups and structured data</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) While vector databases are excellent for storing and retrieving long-term memory embeddings, a complete agent memory system requires a short-term memory buffer for recent conversation context, a long-term memory store (vector database or knowledge graph) for persistent facts and learned information, and a retrieval mechanism to access relevant memories when needed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Using only the LLM's context window</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Storing conversations in a list provides basic history but doesn't distinguish between short-term context and long-term persistent facts that need to be retrieved</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 10: What is the relationship between the LLM Core and other agent components?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) There is no difference</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Although agents may use different model architectures, the number of parameters doesn't define what makes an agent different</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">C) LLM Core serves as the reasoning engine that uses memory for context, interfaces with tools through Tool Interface, creates plans via Planner, and processes results from Action Executor</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) While processing speed and model size can vary between implementations, the fundamental distinction between agents and traditional LLMs is their ability to autonomously use tools, access real-time data, make decisions, and take actions that affect the environment, not just generate text responses</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 11: Interview question: "How would you handle tool execution failures in an agent system?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) It stores memory</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) While text generation is handled by the LLM, the tool interface specifically manages registration, selection, and execution of external tools and APIs</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">C) Implement error handling with retry logic, fallback tools, error reporting to LLM for alternative planning, and graceful degradation</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) The tool interface is specifically responsible for managing agent interactions with external systems: it registers available tools, provides tool descriptions to the LLM for selection, handles tool execution with proper parameter passing, manages error handling for tool failures, and integrates tool results back into the agent's reasoning process</div>
                            </div>
                        <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 12: In the agent state representation state = (M, T, G, H), what does H represent?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) There is no difference</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">B) History of actions taken by the agent</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Although agents may use different model architectures, the number of parameters doesn't define what makes an agent different</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) While processing speed and model size can vary between implementations, the fundamental distinction between agents and traditional LLMs is their ability to autonomously use tools, access real-time data, make decisions, and take actions that affect the environment, not just generate text responses</div>
                            </div>
                        </div>
                            </div>
                        </div>
                            </div>
                        </div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </section>
    </main>

    <footer style="background: #f8f9fa; padding: 2rem 0; margin-top: 3rem; border-top: 2px solid #5B7553;">
        <div class="azbn-container" style="text-align: center;">
            <button onclick="scrollToSectionNav()" class="azbn-btn" style="margin: 0.5rem;">
                ‚Üë Back to Section Navigation
            </button>
            <div style="margin-top: 1.5rem;">
                <a href="/tutorials/agentic-ai" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Back to Tutorial</a>
                <a href="/tutorials/agentic-ai/chapter1" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Chapter 1</a>
                <a href="/tutorials/agentic-ai/chapter3" class="azbn-btn" style="text-decoration: none; margin: 0.5rem;">Chapter 3 ‚Üí</a>
            </div>
        </div>
    </footer>
    
    <!-- KaTeX for math rendering -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
    <script src="{{ url_for('static', filename='js/tutorials/shared-quiz.js') }}?v=2"></script>
    <script src="{{ url_for('static', filename='js/tutorials/agentic-ai/shared-tutorial.js') }}"></script>
    <script>
        function scrollToSectionNav() {
            const sectionNav = document.querySelector('.section-nav');
            if (sectionNav) {
                sectionNav.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        

            
// Initialize KaTeX rendering - ensure KaTeX is loaded first
        function initKaTeX() {
            if (typeof katex !== 'undefined' && typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: "$$", right: "$$", display: true},
                        {left: "\\[", right: "\\]", display: true},
                        {left: "$", right: "$", display: false},
                        {left: "\\(", right: "\\)", display: false}
                    ],
                    throwOnError: false
                });
            } else {
                // Retry if KaTeX not loaded yet
                setTimeout(initKaTeX, 100);
                return;
            }
            
            // Initialize Prism.js syntax highlighting
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        }
        
        // Wait for DOM and KaTeX to be ready
        if (document.readyState === 'loading') {
            document.addEventListener("DOMContentLoaded", initKaTeX);
        } else {
            // DOM already loaded, wait for KaTeX
            initKaTeX();
    </script>
</body>
</html>