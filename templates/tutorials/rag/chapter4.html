<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 4: Vector Databases - RAG & Retrieval Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/tutorials/rag/rag.css') }}">
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <!-- Prism.js for code syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>


</head>
<body>
    <header class="azbn-header">
        <nav class="azbn-nav">
            <div class="azbn-container">
                <a href="/tutorials/rag" class="course-link">
                    <span>RAG & Retrieval Systems</span>
                </a>
                <div class="azbn-links">
                    <a href="/">Home</a>
                    <a href="/#about">About</a>
                    <a href="/tutorials/">Tutorials</a>
                    <a href="/#projects">Projects</a>
                    <a href="/contact">Contact</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        <div class="tutorial-header">
            <div class="azbn-container">
                <h1 class="chapter-title">Chapter 4: Vector Databases</h1>
                <p class="chapter-subtitle">Storing and Searching Embeddings</p>
                
                <div class="chapter-progress">
                    <div class="chapter-progress-fill" data-progress="57"></div>
                </div>
                
                <div class="chapter-navigation">
                    <a href="/tutorials/rag/chapter1" class="chapter-nav-btn ">Chapter 1</a>
                    <a href="/tutorials/rag/chapter2" class="chapter-nav-btn ">Chapter 2</a>
                    <a href="/tutorials/rag/chapter3" class="chapter-nav-btn ">Chapter 3</a>
                    <a href="/tutorials/rag/chapter4" class="chapter-nav-btn active">Chapter 4</a>
                    <a href="/tutorials/rag/chapter5" class="chapter-nav-btn ">Chapter 5</a>
                    <a href="/tutorials/rag/chapter6" class="chapter-nav-btn ">Chapter 6</a>
                    <a href="/tutorials/rag/chapter7" class="chapter-nav-btn ">Chapter 7</a>
                </div>
                
                <div class="section-progress">
                    <div class="section-progress-fill" data-progress="14.3"></div>
                </div>
                
                <div class="section-nav">
                    <button class="section-nav-btn azbn-btn active" data-section="overview">Overview</button>
                    <button class="section-nav-btn azbn-btn" data-section="concepts">Key Concepts</button>
                    <button class="section-nav-btn azbn-btn" data-section="formulas">Formulas</button>
                    <button class="section-nav-btn azbn-btn" data-section="examples">Examples</button>
                    <button class="section-nav-btn azbn-btn" data-section="implementation">Implementation</button>
                    <button class="section-nav-btn azbn-btn" data-section="applications">Applications</button>
                    <button class="section-nav-btn azbn-btn" data-section="quiz">Quiz</button>
                </div>
            </div>
        </div>

        <section class="azbn-section">
            <div class="azbn-container">
                <div class="learning-objectives-box">
                    <h2>Learning Objectives</h2>
                    <ul>
                        <li>Understand vector databases fundamentals</li>
                        <li>Master the mathematical foundations</li>
                        <li>Learn practical implementation</li>
                        <li>Apply knowledge through examples</li>
                        <li>Recognize real-world applications</li>
                    </ul>
                </div>

                <main class="chapter-main-content">
                    <div id="overview" class="content-section active">
                        <h2>Vector Databases</h2>
                        
                        <div class="explanation-box">
                            <h3>Introduction</h3>
                            <p><strong>Storing and Searching Embeddings</strong></p>
                            <p>This chapter provides comprehensive coverage of vector databases, including detailed explanations, mathematical formulations, code implementations, and real-world examples.</p>
                        </div>

                        <div class="example-box">
                            <h4>üìö Why This Matters</h4>
                            <p>Understanding vector databases is crucial for mastering modern AI systems. This chapter breaks down complex concepts into digestible explanations with step-by-step examples.</p>
                        </div>
                    </div>

                    <div id="concepts" class="content-section">
                        <h2>Key Concepts</h2>
                        
                        <div class="explanation-box">
                            <h3>Why Chunking is Important</h3>
                            <p><strong>Problem:</strong> Documents are often too long for LLM context windows or embedding models.</p>
                            
                            <p><strong>Solution:</strong> Split documents into smaller chunks that:</p>
                            <ul>
                                <li>Fit within context limits</li>
                                <li>Are semantically meaningful</li>
                                <li>Can be retrieved independently</li>
                                <li>Maintain context when possible</li>
                            </ul>
                        </div>
                        
                        <div class="explanation-box">
                            <h3>Chunking Strategies</h3>
                            <p><strong>Fixed-size chunking:</strong></p>
                            <ul>
                                <li>Split by character/token count</li>
                                <li>Simple but may break sentences</li>
                                <li>Fast and predictable</li>
                            </ul>
                            
                            <p><strong>Sentence-based chunking:</strong></p>
                            <ul>
                                <li>Split at sentence boundaries</li>
                                <li>Preserves sentence integrity</li>
                                <li>Better semantic coherence</li>
                            </ul>
                            
                            <p><strong>Semantic chunking:</strong></p>
                            <ul>
                                <li>Group related sentences together</li>
                                <li>Uses embeddings to find boundaries</li>
                                <li>Most semantically coherent</li>
                            </ul>
                        </div>
                        
                        <div class="explanation-box">
                            <h3>Chunk Overlap</h3>
                            <p><strong>Why overlap:</strong> Prevents losing context at chunk boundaries. Important information at boundaries can be preserved.</p>
                            
                            <p><strong>Typical overlap:</strong> 10-20% of chunk size. Too much overlap wastes storage, too little loses context.</p>
                        </div>
                    </div>

                    <div id="formulas" class="content-section">
                        <h2>Mathematical Formulations</h2>
                        
                        <div class="formula-box">
                            <h4>Chunk Size Calculation</h4>
                            <div class="formula-display">
                                \[\text{chunks} = \left\lceil \frac{\text{document\_length}}{\text{chunk\_size} - \text{overlap}} \right\rceil\]
                            </div>
                            <div class="formula-explanation">
                                <h5>Where:</h5>
                                <ul>
                                    <li>\(\text{document\_length}\): Total length of document (characters or tokens)</li>
                                    <li>\(\text{chunk\_size}\): Desired chunk size</li>
                                    <li>\(\text{overlap}\): Overlap between chunks</li>
                                    <li>Effective chunk size: chunk_size - overlap</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="formula-box">
                            <h4>Overlap Percentage</h4>
                            <div class="formula-display">
                                \[\text{overlap\_percentage} = \frac{\text{overlap}}{\text{chunk\_size}} \times 100\%\]
                            </div>
                            <div class="formula-explanation">
                                <p>Typical overlap: 10-20%. Ensures context is preserved at chunk boundaries.</p>
                            </div>
                        </div>
                        
                        <div class="formula-box">
                            <h4>Storage Efficiency</h4>
                            <div class="formula-display">
                                \[\text{storage\_ratio} = \frac{\text{total\_chunks} \times \text{chunk\_size}}{\text{document\_length}}\]
                            </div>
                            <div class="formula-explanation">
                                <p>With overlap, storage_ratio > 1. Higher overlap = more storage but better context preservation.</p>
                            </div>
                        </div>
                    </div>

                    <div id="examples" class="content-section">
                        <h2>Detailed Examples</h2>
                        
                        <div class="example-box">
                            <h4>Example: Fixed-Size Chunking</h4>
                            <p><strong>Document:</strong> "Python is a programming language. It is widely used for data science. Machine learning uses Python extensively."</p>
                            
                            <p><strong>Chunk size:</strong> 50 characters, overlap: 10 characters</p>
                            
                            <p><strong>Chunks:</strong></p>
                            <ul>
                                <li>Chunk 1: "Python is a programming language. It is widely used for data"</li>
                                <li>Chunk 2: "for data science. Machine learning uses Python extensively."</li>
                            </ul>
                            
                            <p><strong>Note:</strong> Overlap ensures "for data" appears in both chunks, preserving context.</p>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Sentence-Based Chunking</h4>
                            <p><strong>Document:</strong> "Python is a programming language. It is widely used. Machine learning uses Python."</p>
                            
                            <p><strong>Chunk size:</strong> 2 sentences</p>
                            
                            <p><strong>Chunks:</strong></p>
                            <ul>
                                <li>Chunk 1: "Python is a programming language. It is widely used."</li>
                                <li>Chunk 2: "It is widely used. Machine learning uses Python."</li>
                            </ul>
                            
                            <p><strong>Advantage:</strong> Preserves sentence integrity, better semantic coherence.</p>
                        </div>
                    </div>

                    <div id="implementation" class="content-section">
                        <h2>Implementation</h2>
                        
                        <div class="code-box">
                            <h4>Code Implementation</h4>
                            <pre><code class="language-python">from langchain.text_splitter import CharacterTextSplitter, RecursiveCharacterTextSplitter

# Fixed-size chunking
text_splitter = CharacterTextSplitter(
    separator="\n",
    chunk_size=1000,
    chunk_overlap=200,
    length_function=len
)

text = "Your long document text here..."
chunks = text_splitter.split_text(text)

# Recursive chunking (tries multiple separators)
recursive_splitter = RecursiveCharacterTextSplitter(
    chunk_size=1000,
    chunk_overlap=200,
    length_function=len,
    separators=["\n\n", "\n", " ", ""]
)

chunks = recursive_splitter.split_text(text)

# Sentence-based chunking
from langchain.text_splitter import SentenceTransformersTokenTextSplitter

splitter = SentenceTransformersTokenTextSplitter(
    chunk_overlap=50,
    model_name="sentence-transformers/all-MiniLM-L6-v2"
)

chunks = splitter.split_text(text)</code></pre>
                        </div>
                    </div>

                    <div id="applications" class="content-section">
                        <h2>Real-World Applications</h2>
                        
                        <div class="explanation-box">
                            <h3>Chunking in RAG Systems</h3>
                            <p><strong>Document processing:</strong> Split large documents into manageable chunks for embedding and retrieval</p>
                            <p><strong>Context management:</strong> Ensure chunks fit within LLM context windows</p>
                            <p><strong>Retrieval optimization:</strong> Smaller, focused chunks improve retrieval precision</p>
                            <p><strong>Storage efficiency:</strong> Balance between chunk size and storage costs</p>
                        </div>
                        
                        <div class="explanation-box">
                            <h3>Best Practices</h3>
                            <p><strong>Chunk size:</strong> 200-1000 tokens (depends on embedding model and LLM context)</p>
                            <p><strong>Overlap:</strong> 10-20% of chunk size</p>
                            <p><strong>Strategy:</strong> Use semantic chunking when possible, fallback to sentence-based, then fixed-size</p>
                            <p><strong>Testing:</strong> Evaluate retrieval quality with different chunk sizes</p>
                        </div>
                    </div>

                    <div id="quiz" class="content-section">
                        <h2>Test Your Understanding</h2>
                        
                        <div class="quiz-container">
                            <div class="quiz-question">
                                <h3>Question 1: What is a vector database?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) A specialized database optimized for storing and efficiently searching high-dimensional vector embeddings using similarity search algorithms</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) A regular SQL database</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) A text storage system</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) A file system</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 2: Interview question: "What are the key features of vector databases for RAG?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Fast approximate nearest neighbor (ANN) search, scalable to millions of vectors, metadata filtering, real-time updates, and support for similarity metrics (cosine, Euclidean, dot product)</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Only fast search</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Only storage</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Only metadata</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 3: What are popular vector databases used in RAG systems?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Pinecone, Weaviate, Chroma, Qdrant, FAISS, Milvus, and pgvector (PostgreSQL extension)</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Only MySQL</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Only MongoDB</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Only Redis</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 4: Interview question: "What is HNSW indexing and why is it used in vector databases?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Hierarchical Navigable Small World - a graph-based ANN algorithm that provides fast approximate search with good accuracy, commonly used in production vector databases</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) A compression algorithm</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) A sorting method</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) A storage format</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 5: What is IVF (Inverted File Index) in vector databases?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) An indexing method that partitions vector space into clusters (Voronoi cells), enabling faster search by only searching relevant clusters</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) A file format</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) A compression method</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) A query language</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 6: Interview question: "How do you choose between different vector databases?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Consider scale (millions vs billions), deployment (cloud vs self-hosted), features (metadata filtering, real-time updates), cost, ease of use, and integration with your stack</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Always use the cheapest</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Always use the fastest</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Any database works</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 7: What is metadata filtering in vector databases?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Filtering search results by document metadata (date, author, category) before or after similarity search, enabling precise retrieval</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Filtering by vector similarity only</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Compressing metadata</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Metadata is not used</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 8: Interview question: "What is the difference between exact and approximate nearest neighbor search?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Exact search finds true nearest neighbors but is slow for large datasets. Approximate (ANN) is much faster with high accuracy, using indexing (HNSW, IVF) to trade some accuracy for speed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) They are the same</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Exact is always faster</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Approximate is always more accurate</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 9: What is FAISS and when would you use it?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Facebook AI Similarity Search - a library for efficient similarity search, good for self-hosted solutions, research, and when you need fine-grained control over indexing</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) A cloud service</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) A database management system</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) A query language</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 10: Interview question: "How do you handle vector database updates in a production RAG system?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Implement incremental updates, batch processing for large changes, re-indexing strategies, versioning for document updates, and ensure consistency between embeddings and metadata</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Rebuild entire database</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) No updates needed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Manual updates only</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 11: What is the difference between Pinecone and self-hosted solutions like Chroma?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Pinecone is managed cloud service (easy setup, scaling, but cost). Chroma is self-hosted (more control, lower cost, but requires infrastructure management)</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) They are identical</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Pinecone is always better</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Chroma is always better</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 12: Interview question: "How do you scale a vector database for millions of documents?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Use distributed indexing, sharding by metadata or hash, horizontal scaling with multiple nodes, efficient indexing algorithms (HNSW), and consider approximate search for speed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Use a single server</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) No scaling needed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Only vertical scaling</div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </section>
    </main>

    <footer style="background: #f8f9fa; padding: 2rem 0; margin-top: 3rem; border-top: 2px solid #5B7553;">
        <div class="azbn-container" style="text-align: center;">
            <button onclick="scrollToSectionNav()" class="azbn-btn" style="margin: 0.5rem;">
                ‚Üë Back to Section Navigation
            </button>
            <div style="margin-top: 1.5rem;">
                <a href="/tutorials/rag" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Back to Tutorial</a>
                <a href="/tutorials/rag/chapter3" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Chapter 3</a>
                <a href="/tutorials/rag/chapter5" class="azbn-btn" style="text-decoration: none; margin: 0.5rem;">Chapter 5 ‚Üí</a>
            </div>
        </div>
    </footer>
    
        <!-- KaTeX for math rendering -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script src="{{ url_for('static', filename='js/tutorials/shared-quiz.js') }}"></script>
<script src="{{ url_for('static', filename='js/tutorials/rag/shared-tutorial.js') }}"></script>
    <script>
            
// Initialize KaTeX rendering - ensure KaTeX is loaded first
        function initKaTeX() {
            if (typeof katex !== 'undefined' && typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: "$$", right: "$$", display: true},
                        {left: "\\[", right: "\\]", display: true},
                        {left: "$", right: "$", display: false},
                        {left: "\\(", right: "\\)", display: false}
                    ],
                    throwOnError: false
                });
            } else {
                // Retry if KaTeX not loaded yet
                setTimeout(initKaTeX, 100);
                return;
            }
            
            // Initialize Prism.js syntax highlighting
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        }
        
        // Wait for DOM and KaTeX to be ready
        if (document.readyState === 'loading') {
            document.addEventListener("DOMContentLoaded", initKaTeX);
        } else {
            // DOM already loaded, wait for KaTeX
            initKaTeX();
    </script>
</body>
</html>