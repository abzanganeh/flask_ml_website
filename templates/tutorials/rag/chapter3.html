<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: Document Processing & Chunking - RAG & Retrieval Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/tutorials/rag/rag.css') }}">
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <!-- Prism.js for code syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>


</head>
<body>
    <header class="azbn-header">
        <nav class="azbn-nav">
            <div class="azbn-container">
                <a href="/tutorials/rag" class="course-link">
                    <span>RAG & Retrieval Systems</span>
                </a>
                <div class="azbn-links">
                    <a href="/">Home</a>
                    <a href="/#about">About</a>
                    <a href="/tutorials/">Tutorials</a>
                    <a href="/#projects">Projects</a>
                    <a href="/contact">Contact</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        <div class="tutorial-header">
            <div class="azbn-container">
                <h1 class="chapter-title">Chapter 3: Document Processing & Chunking</h1>
                <p class="chapter-subtitle">Preparing Documents for Retrieval</p>
                
                <div class="chapter-progress">
                    <div class="chapter-progress-fill" data-progress="42"></div>
                </div>
                
                <div class="chapter-navigation">
                    <a href="/tutorials/rag/chapter1" class="chapter-nav-btn ">Chapter 1</a>
                    <a href="/tutorials/rag/chapter2" class="chapter-nav-btn ">Chapter 2</a>
                    <a href="/tutorials/rag/chapter3" class="chapter-nav-btn active">Chapter 3</a>
                    <a href="/tutorials/rag/chapter4" class="chapter-nav-btn ">Chapter 4</a>
                    <a href="/tutorials/rag/chapter5" class="chapter-nav-btn ">Chapter 5</a>
                    <a href="/tutorials/rag/chapter6" class="chapter-nav-btn ">Chapter 6</a>
                    <a href="/tutorials/rag/chapter7" class="chapter-nav-btn ">Chapter 7</a>
                </div>
                
                <div class="section-progress">
                    <div class="section-progress-fill" data-progress="14.3"></div>
                </div>
                
                <div class="section-nav">
                    <button class="section-nav-btn azbn-btn active" data-section="overview">Overview</button>
                    <button class="section-nav-btn azbn-btn" data-section="concepts">Key Concepts</button>
                    <button class="section-nav-btn azbn-btn" data-section="formulas">Formulas</button>
                    <button class="section-nav-btn azbn-btn" data-section="examples">Examples</button>
                    <button class="section-nav-btn azbn-btn" data-section="implementation">Implementation</button>
                    <button class="section-nav-btn azbn-btn" data-section="applications">Applications</button>
                    <button class="section-nav-btn azbn-btn" data-section="quiz">Quiz</button>
                </div>
            </div>
        </div>

        <section class="azbn-section">
            <div class="azbn-container">
                <div class="learning-objectives-box">
                    <h2>Learning Objectives</h2>
                    <ul>
                        <li>Understand document processing & chunking fundamentals</li>
                        <li>Master the mathematical foundations</li>
                        <li>Learn practical implementation</li>
                        <li>Apply knowledge through examples</li>
                        <li>Recognize real-world applications</li>
                    </ul>
                </div>

                <main class="chapter-main-content">
                    <div id="overview" class="content-section active">
                        <h2>Document Processing & Chunking</h2>
                        
                        <div class="explanation-box">
                            <h3>Introduction</h3>
                            <p><strong>Preparing Documents for Retrieval</strong></p>
                            <p>This chapter provides comprehensive coverage of document processing & chunking, including detailed explanations, mathematical formulations, code implementations, and real-world examples.</p>
                        </div>

                        <div class="example-box">
                            <h4>üìö Why This Matters</h4>
                            <p>Understanding document processing & chunking is crucial for mastering modern AI systems. This chapter breaks down complex concepts into digestible explanations with step-by-step examples.</p>
                        </div>
                    </div>

                    <div id="concepts" class="content-section">
                        <h2>Key Concepts</h2>
                        
                        <div class="explanation-box">
                            <h3>Retrieval Strategies</h3>
                            <p><strong>Dense retrieval (semantic search):</strong></p>
                            <ul>
                                <li>Uses embeddings for semantic similarity</li>
                                <li>Finds documents with similar meaning</li>
                                <li>Handles synonyms and paraphrasing</li>
                                <li>Most common in RAG systems</li>
                            </ul>
                            
                            <p><strong>Sparse retrieval (keyword search):</strong></p>
                            <ul>
                                <li>Uses keyword matching (BM25, TF-IDF)</li>
                                <li>Faster but less semantic understanding</li>
                                <li>Good for exact term matching</li>
                                <li>Often combined with dense retrieval (hybrid)</li>
                            </ul>
                            
                            <p><strong>Hybrid retrieval:</strong></p>
                            <ul>
                                <li>Combines dense and sparse retrieval</li>
                                <li>Reranks results from both methods</li>
                                <li>Best of both worlds</li>
                            </ul>
                        </div>
                        
                        <div class="explanation-box">
                            <h3>Retrieval Parameters</h3>
                            <p><strong>Top-k selection:</strong></p>
                            <ul>
                                <li>Number of documents to retrieve (typically 3-10)</li>
                                <li>More documents = more context but higher cost</li>
                                <li>Fewer documents = faster but may miss relevant info</li>
                            </ul>
                            
                            <p><strong>Similarity threshold:</strong></p>
                            <ul>
                                <li>Minimum similarity score to include document</li>
                                <li>Filters out irrelevant documents</li>
                                <li>Prevents low-quality context</li>
                            </ul>
                        </div>
                        
                        <div class="explanation-box">
                            <h3>Reranking</h3>
                            <p><strong>Why rerank:</strong> Initial retrieval may not perfectly match query intent. Reranking improves relevance.</p>
                            
                            <p><strong>Methods:</strong></p>
                            <ul>
                                <li>Cross-encoder models (more accurate but slower)</li>
                                <li>LLM-based reranking</li>
                                <li>Learning-to-rank algorithms</li>
                            </ul>
                        </div>
                    </div>

                    <div id="formulas" class="content-section">
                        <h2>Mathematical Formulations</h2>
                        
                        <div class="formula-box">
                            <h4>BM25 (Sparse Retrieval)</h4>
                            <div class="formula-display">
                                \[\text{BM25}(q, d) = \sum_{t \in q} \text{IDF}(t) \times \frac{f(t,d) \times (k_1 + 1)}{f(t,d) + k_1 \times (1 - b + b \times \frac{|d|}{\text{avgdl}})}\]
                            </div>
                            <div class="formula-explanation">
                                <h5>Where:</h5>
                                <ul>
                                    <li>\(q\): Query</li>
                                    <li>\(d\): Document</li>
                                    <li>\(f(t,d)\): Term frequency in document</li>
                                    <li>\(\text{IDF}(t)\): Inverse document frequency</li>
                                    <li>\(k_1, b\): Tuning parameters</li>
                                    <li>\(|d|, \text{avgdl}\): Document length and average length</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="formula-box">
                            <h4>Hybrid Score</h4>
                            <div class="formula-display">
                                \[\text{score}(q, d) = \alpha \times \text{BM25}(q, d) + (1 - \alpha) \times \text{cosine}(E(q), E(d))\]
                            </div>
                            <div class="formula-explanation">
                                <h5>Where:</h5>
                                <ul>
                                    <li>\(\alpha\): Weight between sparse and dense (typically 0.3-0.7)</li>
                                    <li>Combines keyword matching with semantic similarity</li>
                                    <li>Often outperforms either method alone</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="formula-box">
                            <h4>Reranking Score</h4>
                            <div class="formula-display">
                                \[\text{rerank\_score}(q, d) = \text{CrossEncoder}([q; d])\]
                            </div>
                            <div class="formula-explanation">
                                <p>Cross-encoder processes query and document together, providing more accurate relevance score than bi-encoder (embedding-based) methods.</p>
                            </div>
                        </div>
                    </div>

                    <div id="examples" class="content-section">
                        <h2>Detailed Examples</h2>
                        
                        <div class="example-box">
                            <h4>Example: Dense vs Sparse Retrieval</h4>
                            <p><strong>Query:</strong> "How do I reset my password?"</p>
                            
                            <p><strong>Dense retrieval (semantic):</strong></p>
                            <ul>
                                <li>Finds: "Password recovery steps", "Reset account access", "Forgot password guide"</li>
                                <li>Understands synonyms: "reset" = "recovery" = "forgot"</li>
                            </ul>
                            
                            <p><strong>Sparse retrieval (keyword):</strong></p>
                            <ul>
                                <li>Finds: Documents containing "reset" AND "password"</li>
                                <li>Misses: "Password recovery" (no "reset" keyword)</li>
                            </ul>
                            
                            <p><strong>Hybrid:</strong> Combines both, gets best results</p>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Reranking</h4>
                            <p><strong>Initial retrieval (top-10):</strong></p>
                            <ul>
                                <li>Doc 1: "Password reset" (score: 0.85)</li>
                                <li>Doc 2: "Account settings" (score: 0.82)</li>
                                <li>Doc 3: "Password recovery" (score: 0.80)</li>
                                <li>...</li>
                            </ul>
                            
                            <p><strong>After reranking:</strong></p>
                            <ul>
                                <li>Doc 3: "Password recovery" (score: 0.92) ‚Üê More relevant!</li>
                                <li>Doc 1: "Password reset" (score: 0.88)</li>
                                <li>Doc 2: "Account settings" (score: 0.65) ‚Üê Less relevant</li>
                            </ul>
                            
                            <p><strong>Result:</strong> Better ordering improves final answer quality</p>
                        </div>
                    </div>

                    <div id="implementation" class="content-section">
                        <h2>Implementation</h2>
                        
                        <div class="code-box">
                            <h4>Hybrid Retrieval</h4>
                            <pre><code class="language-python">from sentence_transformers import SentenceTransformer
from rank_bm25 import BM25Okapi
import numpy as np

class HybridRetriever:
    """Hybrid dense + sparse retrieval"""
    
    def __init__(self, documents, alpha=0.5):
        self.documents = documents
        self.alpha = alpha  # Weight for BM25 vs dense
        
        # Dense retriever
        self.embedder = SentenceTransformer('all-MiniLM-L6-v2')
        self.embeddings = self.embedder.encode(documents)
        
        # Sparse retriever (BM25)
        tokenized_docs = [doc.split() for doc in documents]
        self.bm25 = BM25Okapi(tokenized_docs)
    
    def retrieve(self, query, top_k=5):
        """Retrieve using hybrid approach"""
        # Dense retrieval
        query_embedding = self.embedder.encode([query])
        dense_scores = np.dot(self.embeddings, query_embedding.T).flatten()
        dense_scores = (dense_scores - dense_scores.min()) / (dense_scores.max() - dense_scores.min() + 1e-8)
        
        # Sparse retrieval
        tokenized_query = query.split()
        sparse_scores = self.bm25.get_scores(tokenized_query)
        sparse_scores = (sparse_scores - sparse_scores.min()) / (sparse_scores.max() - sparse_scores.min() + 1e-8)
        
        # Combine
        hybrid_scores = self.alpha * sparse_scores + (1 - self.alpha) * dense_scores
        
        # Get top-k
        top_indices = np.argsort(hybrid_scores)[-top_k:][::-1]
        return [self.documents[i] for i in top_indices]

# Example
docs = ["Password reset instructions", "Account settings guide", "Password recovery steps"]
retriever = HybridRetriever(docs)
results = retriever.retrieve("How do I reset my password?")
print(results)</code></pre>
                        </div>
                        
                        <div class="code-box">
                            <h4>Reranking with Cross-Encoder</h4>
                            <pre><code class="language-python">from sentence_transformers import CrossEncoder

class Reranker:
    """Rerank retrieved documents"""
    
    def __init__(self):
        self.model = CrossEncoder('cross-encoder/ms-marco-MiniLM-L-6-v2')
    
    def rerank(self, query, documents, top_k=3):
        """Rerank documents for query"""
        # Create query-document pairs
        pairs = [[query, doc] for doc in documents]
        
        # Get scores
        scores = self.model.predict(pairs)
        
        # Sort by score
        ranked_indices = np.argsort(scores)[::-1]
        
        # Return top-k
        return [documents[i] for i in ranked_indices[:top_k]]

# Example
reranker = Reranker()
docs = ["Password reset", "Account settings", "Password recovery"]
reranked = reranker.rerank("How do I reset my password?", docs)
print(reranked)</code></pre>
                        </div>
                    </div>

                    <div id="applications" class="content-section">
                        <h2>Real-World Applications</h2>
                        
                        <div class="explanation-box">
                            <h3>Retrieval Strategy Selection</h3>
                            <p><strong>Use dense retrieval when:</strong></p>
                            <ul>
                                <li>Semantic understanding is important</li>
                                <li>Users may phrase queries differently</li>
                                <li>Domain-specific terminology</li>
                            </ul>
                            
                            <p><strong>Use sparse retrieval when:</strong></p>
                            <ul>
                                <li>Exact keyword matching is important</li>
                                <li>Speed is critical</li>
                                <li>Technical documentation with specific terms</li>
                            </ul>
                            
                            <p><strong>Use hybrid when:</strong></p>
                            <ul>
                                <li>You want best of both worlds</li>
                                <li>High accuracy is required</li>
                                <li>Can afford extra computation</li>
                            </ul>
                        </div>
                        
                        <div class="explanation-box">
                            <h3>Reranking Benefits</h3>
                            <p><strong>When to use reranking:</strong></p>
                            <ul>
                                <li>Initial retrieval returns many candidates</li>
                                <li>Need high precision in top results</li>
                                <li>Can afford additional latency</li>
                                <li>Quality is more important than speed</li>
                            </ul>
                        </div>
                    </div>

                    <div id="quiz" class="content-section">
                        <h2>Test Your Understanding</h2>
                        
                        <div class="quiz-container">
                            <div class="quiz-question">
                                <h3>Question 1: Why is document chunking important in RAG systems?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) LLMs have context limits, chunking breaks documents into manageable pieces that fit in context windows while preserving semantic meaning</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) To make documents smaller</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) To reduce storage</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Chunking is not needed</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 2: Interview question: "What are the different chunking strategies and when would you use each?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Fixed-size: Simple, fast, good for uniform text. Semantic: Preserves meaning, better for varied content. Recursive: Handles nested structures. Use fixed-size for speed, semantic for quality, recursive for structured documents</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Only fixed-size</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Only semantic</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Chunking strategy doesn't matter</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 3: What is chunk overlap and why is it used?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Overlapping chunks share some content to preserve context at boundaries, preventing information loss when sentences/paragraphs are split</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) To reduce storage</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) To make chunks smaller</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Overlap is not needed</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 4: Interview question: "How do you determine optimal chunk size?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Balance LLM context window, retrieval precision (smaller = more precise), and semantic completeness (larger = more context). Common: 200-1000 tokens. Test on your data and downstream task</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Always use 100 tokens</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Always use 5000 tokens</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Chunk size doesn't matter</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 5: What is semantic chunking?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Chunking based on semantic boundaries (sentences, paragraphs, topics) rather than fixed sizes, preserving meaning and context</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Chunking by file size</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Random chunking</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Chunking by word count only</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 6: Interview question: "How do you handle different document types (PDF, HTML, Markdown) in RAG?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Use appropriate parsers (PyPDF2, BeautifulSoup, markdown), extract text while preserving structure, handle metadata, and apply document-type-specific chunking strategies</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Convert all to text first</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Only support one format</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) No special handling needed</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 7: What is metadata extraction in document processing?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Extracting document properties (title, author, date, source, section) to enable filtering and better retrieval in vector databases</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Extracting all text</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Compressing documents</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Metadata is not needed</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 8: Interview question: "How do you preserve context when chunking documents?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Use chunk overlap, preserve sentence/paragraph boundaries, include surrounding context in metadata, and use semantic chunking to keep related content together</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) No context preservation needed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Only use fixed-size chunks</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Split randomly</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 9: What are the trade-offs between small and large chunk sizes?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Small chunks: More precise retrieval but may lose context. Large chunks: More context but less precise retrieval. Balance based on query type and document structure</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Small is always better</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Large is always better</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Size doesn't matter</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 10: Interview question: "How would you handle very long documents (e.g., books) in RAG?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Use hierarchical chunking (chapters ‚Üí sections ‚Üí paragraphs), maintain document structure in metadata, use multi-level retrieval, and consider document summarization for overview</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Split into equal chunks</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Use only first part</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Skip long documents</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 11: What is recursive chunking?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Chunking that tries multiple strategies in order (e.g., paragraphs ‚Üí sentences ‚Üí characters) until chunks fit size requirements, handling nested document structures</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Chunking twice</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Random chunking</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) No difference from fixed-size</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 12: Interview question: "How do you evaluate chunking quality?"</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Measure retrieval performance (precision@k, recall@k), test downstream RAG quality, check if relevant information is preserved, and evaluate chunk coherence</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Only check chunk size</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) No evaluation needed</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Only check number of chunks</div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </section>
    </main>

    <footer style="background: #f8f9fa; padding: 2rem 0; margin-top: 3rem; border-top: 2px solid #5B7553;">
        <div class="azbn-container" style="text-align: center;">
            <button onclick="scrollToSectionNav()" class="azbn-btn" style="margin: 0.5rem;">
                ‚Üë Back to Section Navigation
            </button>
            <div style="margin-top: 1.5rem;">
                <a href="/tutorials/rag" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Back to Tutorial</a>
                <a href="/tutorials/rag/chapter2" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Chapter 2</a>
                <a href="/tutorials/rag/chapter4" class="azbn-btn" style="text-decoration: none; margin: 0.5rem;">Chapter 4 ‚Üí</a>
            </div>
        </div>
    </footer>
    
        <!-- KaTeX for math rendering -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script src="{{ url_for('static', filename='js/tutorials/rag/shared-tutorial.js') }}"></script>
    <script>
        function scrollToSectionNav() {
            const sectionNav = document.querySelector('.section-nav');
            if (sectionNav) {
                sectionNav.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        function checkAnswer(element, isCorrect) {
            element.parentNode.querySelectorAll('.quiz-option').forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
            });
            if (isCorrect) {
                element.classList.add('correct');
                element.textContent += ' ‚úì Correct!';
            } else {
                element.classList.add('incorrect');
                element.textContent += ' ‚úó Incorrect';
                const correctOption = Array.from(element.parentNode.querySelectorAll('.quiz-option'))
                    .find(opt => {
                        const onclick = opt.getAttribute('onclick') || '';
                        return onclick.includes('true');
                    });
                if (correctOption && !correctOption.classList.contains('incorrect')) {
                    correctOption.classList.add('correct');
                    correctOption.textContent += ' ‚úì Correct Answer';
                }
            }
        }
            
// Initialize KaTeX rendering - ensure KaTeX is loaded first
        function initKaTeX() {
            if (typeof katex !== 'undefined' && typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: "$$", right: "$$", display: true},
                        {left: "\\[", right: "\\]", display: true},
                        {left: "$", right: "$", display: false},
                        {left: "\\(", right: "\\)", display: false}
                    ],
                    throwOnError: false
                });
            } else {
                // Retry if KaTeX not loaded yet
                setTimeout(initKaTeX, 100);
                return;
            }
            
            // Initialize Prism.js syntax highlighting
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        }
        
        // Wait for DOM and KaTeX to be ready
        if (document.readyState === 'loading') {
            document.addEventListener("DOMContentLoaded", initKaTeX);
        } else {
            // DOM already loaded, wait for KaTeX
            initKaTeX();
    </script>
</body>
</html>