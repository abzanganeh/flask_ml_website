<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 7: Long Short-Term Memory (LSTM) - Neural Networks Fundamentals</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/tutorials/neural-networks/neural-networks.css') }}">
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <!-- Prism.js for code syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>


</head>
<body>
    <header class="azbn-header">
        <nav class="azbn-nav">
            <div class="azbn-container">
                <a href="/tutorials/neural-networks" class="course-link">
                    <span>Neural Networks Fundamentals</span>
                </a>
                <div class="azbn-links">
                    <a href="/">Home</a>
                    <a href="/#about">About</a>
                    <a href="/tutorials/">Tutorials</a>
                    <a href="/#projects">Projects</a>
                    <a href="/contact">Contact</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        <div class="tutorial-header">
            <div class="azbn-container">
                <h1 class="chapter-title">Chapter 7: Long Short-Term Memory (LSTM)</h1>
                <p class="chapter-subtitle">Solving the vanishing gradient problem with gated memory cells</p>
                
                <div class="chapter-progress">
                    <div class="chapter-progress-fill" data-progress="87.5"></div>
                </div>
                
                <div class="chapter-navigation">
                    <a href="/tutorials/neural-networks/chapter1" class="chapter-nav-btn">Chapter 1</a>
                    <a href="/tutorials/neural-networks/chapter2" class="chapter-nav-btn">Chapter 2</a>
                    <a href="/tutorials/neural-networks/chapter3" class="chapter-nav-btn">Chapter 3</a>
                    <a href="/tutorials/neural-networks/chapter4" class="chapter-nav-btn">Chapter 4</a>
                    <a href="/tutorials/neural-networks/chapter5" class="chapter-nav-btn">Chapter 5</a>
                    <a href="/tutorials/neural-networks/chapter6" class="chapter-nav-btn">Chapter 6</a>
                    <a href="/tutorials/neural-networks/chapter7" class="chapter-nav-btn active">Chapter 7</a>
                    <a href="/tutorials/neural-networks/chapter8" class="chapter-nav-btn">Chapter 8</a>
                </div>
                
                <div class="section-progress">
                    <div class="section-progress-fill" data-progress="14.3"></div>
                </div>
                
                <div class="section-nav">
                    <button class="section-nav-btn azbn-btn active" data-section="overview">Overview</button>
                    <button class="section-nav-btn azbn-btn" data-section="problem">The Problem</button>
                    <button class="section-nav-btn azbn-btn" data-section="gates">LSTM Gates</button>
                    <button class="section-nav-btn azbn-btn" data-section="cell">Cell State</button>
                    <button class="section-nav-btn azbn-btn" data-section="formulas">LSTM Formulas</button>
                    <button class="section-nav-btn azbn-btn" data-section="implementation">Implementation</button>
                    <button class="section-nav-btn azbn-btn" data-section="quiz">Quiz</button>
                </div>
            </div>
        </div>

        <section class="azbn-section">
            <div class="azbn-container">
                <div class="learning-objectives-box">
                    <h2>Learning Objectives</h2>
                    <ul>
                        <li>Understand why LSTMs solve the vanishing gradient problem</li>
                        <li>Master the three gates: forget, input, and output</li>
                        <li>Learn the cell state and hidden state mechanism</li>
                        <li>Understand the complete LSTM forward pass</li>
                        <li>Implement an LSTM from scratch</li>
                        <li>Compare LSTMs with standard RNNs</li>
                    </ul>
                </div>

                <main class="chapter-main-content">
                    <div id="overview" class="content-section active">
                        <h2>What is LSTM?</h2>
                        
                        <div class="explanation-box">
                            <h3>üß† Gated Memory Networks</h3>
                            <p><strong>Long Short-Term Memory (LSTM) networks are a special type of RNN designed to solve the vanishing gradient problem.</strong> They use gating mechanisms to selectively remember or forget information, allowing them to learn long-term dependencies.</p>
                            
                            <p><strong>Think of LSTM as an advanced memory system:</strong></p>
                            <ul>
                                <li><strong>Standard RNN:</strong> Like a person with short-term memory - they remember recent things but forget older information</li>
                                <li><strong>LSTM:</strong> Like a person with both short-term and long-term memory - they can remember important things from much earlier</li>
                                <li><strong>Key difference:</strong> LSTMs have explicit mechanisms (gates) to decide what to remember and what to forget</li>
                            </ul>
                        </div>

                        <div class="explanation-box">
                            <h4>Why LSTMs Were Invented</h4>
                            <p><strong>The fundamental problem with standard RNNs:</strong></p>
                            
                            <div class="example-box">
                                <h5>Real-World Example: Understanding Long Sentences</h5>
                                <p><strong>Sentence:</strong> "The cat, which was very fluffy and had been sleeping on the mat all afternoon, finally woke up and stretched."</p>
                                
                                <p><strong>Standard RNN problem:</strong></p>
                                <ul>
                                    <li>By the time we reach "stretched", the RNN has processed many words</li>
                                    <li>The information about "cat" from the beginning has been multiplied many times</li>
                                    <li>Like a game of telephone - the message gets distorted and lost</li>
                                    <li>Result: The RNN might forget that "stretched" refers to the "cat"</li>
                                </ul>
                                
                                <p><strong>LSTM solution:</strong></p>
                                <ul>
                                    <li>LSTM has a special "cell state" that acts like a conveyor belt</li>
                                    <li>Important information (like "cat") can be stored in the cell state</li>
                                    <li>This information flows through time without being multiplied</li>
                                    <li>Result: LSTM remembers "cat" even after many words, so "stretched" correctly refers to it</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h4>Key Innovations of LSTMs</h4>
                            
                            <div class="explanation-box">
                                <h5>1. Cell State: The Information Highway</h5>
                                <p><strong>The cell state is like a conveyor belt that runs through the entire sequence:</strong></p>
                                <ul>
                                    <li>Information can be added to it or removed from it</li>
                                    <li>But it flows through time <strong>without being multiplied</strong></li>
                                    <li>This is the key to solving vanishing gradients!</li>
                                    <li><strong>Analogy:</strong> Like a river - water flows continuously, and you can add or remove things, but the flow itself doesn't shrink</li>
                                </ul>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>2. Gates: Selective Memory Control</h5>
                                <p><strong>LSTMs have three gates that control information flow:</strong></p>
                                <ul>
                                    <li><strong>Forget Gate:</strong> "What should I forget from the past?"</li>
                                    <li><strong>Input Gate:</strong> "What new information should I remember?"</li>
                                    <li><strong>Output Gate:</strong> "What information should I use for the current output?"</li>
                                </ul>
                                <p><strong>Key insight:</strong> These gates are learned - the network learns what to remember and what to forget!</p>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>3. Additive Updates: No Gradient Shrinking</h5>
                                <p><strong>Standard RNN:</strong> h_t = f(h_{t-1}, x_t) - information is transformed (multiplied)</p>
                                <p><strong>LSTM:</strong> C_t = f_t ‚äô C_{t-1} + i_t ‚äô CÃÉ_t - information is added</p>
                                <ul>
                                    <li>Addition allows gradients to flow through without shrinking</li>
                                    <li>This is the mathematical key to solving vanishing gradients</li>
                                    <li><strong>Analogy:</strong> Like adding items to a list vs transforming the entire list - addition preserves information</li>
                                </ul>
                            </div>
                        </div>

                        <div class="example-box">
                            <h4>üìö Detailed Analogy: LSTM as a Smart Filing System</h4>
                            <p><strong>Think of LSTM like an intelligent filing system:</strong></p>
                            
                            <div class="explanation-box">
                                <h5>The Filing Cabinet (Cell State)</h5>
                                <ul>
                                    <li>This is your long-term storage - information stays here across time</li>
                                    <li>Like a physical filing cabinet, you can add files or remove files</li>
                                    <li>But the cabinet itself (the structure) remains constant</li>
                                    <li><strong>Key:</strong> Information in the cabinet doesn't degrade over time</li>
                                </ul>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>The Three Gates (Smart Decisions)</h5>
                                <ul>
                                    <li><strong>Forget Gate:</strong> Like a secretary who reviews old files and decides which ones to archive/delete
                                        <ul>
                                            <li>Looks at current context and old information</li>
                                            <li>Decides: "This old information is no longer relevant"</li>
                                            <li>Removes it from the cabinet</li>
                                        </ul>
                                    </li>
                                    <li><strong>Input Gate:</strong> Like a secretary who reviews new documents and decides which ones to file
                                        <ul>
                                            <li>Looks at new information and current context</li>
                                            <li>Decides: "This new information is important"</li>
                                            <li>Adds it to the cabinet</li>
                                        </ul>
                                    </li>
                                    <li><strong>Output Gate:</strong> Like a secretary who decides what information to show you
                                        <ul>
                                            <li>Looks at what's in the cabinet</li>
                                            <li>Decides: "This information is relevant for the current task"</li>
                                            <li>Makes it available (hidden state)</li>
                                        </ul>
                                    </li>
                            </ul>
                            </div>
                        </div>

                        <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border: 2px solid #0ea5e9; border-radius: 12px; padding: 2rem; margin: 2rem 0;">
                            <h4 style="color: #0c4a6e; margin-bottom: 1.5rem; text-align: center;">üîÑ LSTM Gate Flow Visualization</h4>
                            
                            <div style="background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                <!-- Input and Previous State -->
                                <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 2rem; flex-wrap: wrap; gap: 1rem;">
                                    <div style="text-align: center; flex: 1; min-width: 150px;">
                                        <div style="background: #dbeafe; border: 2px solid #3b82f6; border-radius: 8px; padding: 1rem;">
                                            <p style="font-weight: 700; color: #1e40af; margin: 0; font-size: 0.9rem;">Input x_t</p>
                                            <p style="font-size: 0.85rem; color: #1e40af; margin: 0.3rem 0 0 0;">Current word</p>
                                        </div>
                                    </div>
                                    <div style="text-align: center; flex: 1; min-width: 150px;">
                                        <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 8px; padding: 1rem;">
                                            <p style="font-weight: 700; color: #166534; margin: 0; font-size: 0.9rem;">h_{t-1}</p>
                                            <p style="font-size: 0.85rem; color: #166534; margin: 0.3rem 0 0 0;">Previous hidden</p>
                                        </div>
                                    </div>
                                    <div style="text-align: center; flex: 1; min-width: 150px;">
                                        <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 1rem;">
                                            <p style="font-weight: 700; color: #92400e; margin: 0; font-size: 0.9rem;">C_{t-1}</p>
                                            <p style="font-size: 0.85rem; color: #92400e; margin: 0.3rem 0 0 0;">Previous cell state</p>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="text-align: center; margin: 1rem 0;">
                                    <div style="font-size: 1.5rem; color: #0ea5e9; font-weight: bold;">‚Üì</div>
                                </div>
                                
                                <!-- Three Gates -->
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 2rem;">
                                    <div style="background: #fee2e2; border: 2px solid #ef4444; border-radius: 8px; padding: 1rem; text-align: center;">
                                        <p style="font-weight: 700; color: #991b1b; margin: 0 0 0.5rem 0; font-size: 0.9rem;">Forget Gate</p>
                                        <p style="font-size: 0.8rem; color: #991b1b; margin: 0;">f_t = œÉ(...)</p>
                                        <p style="font-size: 0.75rem; color: #991b1b; margin: 0.3rem 0 0 0;">What to forget?</p>
                                    </div>
                                    <div style="background: #dbeafe; border: 2px solid #3b82f6; border-radius: 8px; padding: 1rem; text-align: center;">
                                        <p style="font-weight: 700; color: #1e40af; margin: 0 0 0.5rem 0; font-size: 0.9rem;">Input Gate</p>
                                        <p style="font-size: 0.8rem; color: #1e40af; margin: 0;">i_t = œÉ(...)</p>
                                        <p style="font-size: 0.75rem; color: #1e40af; margin: 0.3rem 0 0 0;">What to remember?</p>
                                    </div>
                                    <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 1rem; text-align: center;">
                                        <p style="font-weight: 700; color: #92400e; margin: 0 0 0.5rem 0; font-size: 0.9rem;">Output Gate</p>
                                        <p style="font-size: 0.8rem; color: #92400e; margin: 0;">o_t = œÉ(...)</p>
                                        <p style="font-size: 0.75rem; color: #92400e; margin: 0.3rem 0 0 0;">What to output?</p>
                                    </div>
                                </div>
                                
                                <div style="text-align: center; margin: 1rem 0;">
                                    <div style="font-size: 1.5rem; color: #0ea5e9; font-weight: bold;">‚Üì</div>
                                </div>
                                
                                <!-- Cell State Update -->
                                <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem;">
                                    <p style="font-weight: 700; color: #166534; margin: 0 0 1rem 0; text-align: center;">Cell State Update</p>
                                    <div style="background: white; padding: 1rem; border-radius: 6px; text-align: center;">
                                        <p style="font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; color: #166534; margin: 0;">
                                            C_t = f_t ‚äô C_{t-1} + i_t ‚äô CÃÉ_t
                                        </p>
                                        <p style="font-size: 0.8rem; color: #166534; margin: 0.5rem 0 0 0;">
                                            (Forget old) + (Add new)
                                        </p>
                                    </div>
                                </div>
                                
                                <div style="text-align: center; margin: 1rem 0;">
                                    <div style="font-size: 1.5rem; color: #0ea5e9; font-weight: bold;">‚Üì</div>
                                </div>
                                
                                <!-- Output -->
                                <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 1rem;">
                                    <div style="text-align: center; flex: 1; min-width: 150px;">
                                        <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 8px; padding: 1rem;">
                                            <p style="font-weight: 700; color: #166534; margin: 0; font-size: 0.9rem;">h_t</p>
                                            <p style="font-size: 0.85rem; color: #166534; margin: 0.3rem 0 0 0;">New hidden state</p>
                                        </div>
                                    </div>
                                    <div style="text-align: center; flex: 1; min-width: 150px;">
                                        <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 1rem;">
                                            <p style="font-weight: 700; color: #92400e; margin: 0; font-size: 0.9rem;">C_t</p>
                                            <p style="font-size: 0.85rem; color: #92400e; margin: 0.3rem 0 0 0;">New cell state</p>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 1rem; margin-top: 1.5rem; border-radius: 4px;">
                                    <p style="margin: 0; color: #0c4a6e; font-size: 0.9rem;"><strong>üí° Key:</strong> The three gates control information flow. Forget gate removes old info, Input gate adds new info, Output gate decides what to use. The cell state (C_t) flows through time without degradation!</p>
                                </div>
                            </div>
                        </div>
                            
                            <div class="explanation-box">
                                <h5>The Complete Process</h5>
                                <p><strong>When processing a new word:</strong></p>
                                <ol>
                                    <li><strong>Forget Gate:</strong> Reviews old files, decides what to remove</li>
                                    <li><strong>Input Gate:</strong> Reviews new information, decides what to add</li>
                                    <li><strong>Update Cabinet:</strong> Remove old files, add new files</li>
                                    <li><strong>Output Gate:</strong> Decides what information from the cabinet to use</li>
                                    <li><strong>Result:</strong> You have an updated understanding that combines old and new information</li>
                                </ol>
                            </div>
                        </div>
                    </div>

                    <div id="problem" class="content-section">
                        <h2>The Problem LSTMs Solve</h2>
                        
                        <div class="explanation-box">
                            <h3>‚ö†Ô∏è Vanishing Gradients in RNNs</h3>
                            <p><strong>Standard RNNs suffer from vanishing gradients because:</strong></p>
                            <ul>
                                <li>Gradients are multiplied by W_hh at each time step</li>
                                <li>If |W_hh| < 1, gradients shrink exponentially</li>
                                <li>Early time steps receive almost no gradient</li>
                                <li>Can't learn long-term dependencies</li>
                            </ul>
                        </div>

                        <div class="formula-box">
                            <h4>RNN Gradient Problem</h4>
                            <p><strong>In RNNs, gradient at time t-k:</strong></p>
                            
                            <div class="formula-display">
                                <strong>‚àÇL/‚àÇh_{t-k} = ‚àÇL/‚àÇh_t √ó (W_hh)^k √ó tanh'(z_{t-k}) √ó ... √ó tanh'(z_t)</strong>
                            </div>
                            
                            <p><strong>Problem:</strong> If W_hh < 1, (W_hh)^k ‚Üí 0 as k increases</p>
                            
                            <div class="formula-explanation">
                                <h5>LSTM Solution:</h5>
                                <ul>
                                    <li>Uses <strong>additive</strong> updates instead of multiplicative</li>
                                    <li>Cell state: C_t = f_t ‚äô C_{t-1} + i_t ‚äô CÃÉ_t</li>
                                    <li>Gradients can flow through addition (no shrinking!)</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div id="gates" class="content-section">
                        <h2>The Three Gates</h2>
                        
                        <div class="explanation-box">
                            <h3>üö™ Gate Mechanism</h3>
                            <p><strong>LSTMs use three gates to control information flow:</strong></p>
                        </div>

                        <h3>1. Forget Gate</h3>
                        <div class="formula-box">
                            <h4>Forget Gate Formula</h4>
                            
                            <div class="formula-display">
                                <strong>f_t = œÉ(W_f √ó [h_{t-1}, x_t] + b_f)</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Purpose:</h5>
                                <ul>
                                    <li>Decides what information to <strong>forget</strong> from cell state</li>
                                    <li>Output: 0 (forget) to 1 (keep)</li>
                                    <li>Applied to previous cell state: f_t ‚äô C_{t-1}</li>
                                </ul>
                            </div>
                        </div>

                        <h3>2. Input Gate</h3>
                        <div class="formula-box">
                            <h4>Input Gate Formula</h4>
                            
                            <div class="formula-display">
                                <strong>i_t = œÉ(W_i √ó [h_{t-1}, x_t] + b_i)</strong><br>
                                <strong>CÃÉ_t = tanh(W_C √ó [h_{t-1}, x_t] + b_C)</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Purpose:</h5>
                                <ul>
                                    <li><strong>i_t:</strong> Decides which values to update</li>
                                    <li><strong>CÃÉ_t:</strong> New candidate values</li>
                                    <li>Together: i_t ‚äô CÃÉ_t (what new information to add)</li>
                                </ul>
                            </div>
                        </div>

                        <h3>3. Output Gate</h3>
                        <div class="formula-box">
                            <h4>Output Gate Formula</h4>
                            
                            <div class="formula-display">
                                <strong>o_t = œÉ(W_o √ó [h_{t-1}, x_t] + b_o)</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Purpose:</h5>
                                <ul>
                                    <li>Decides what parts of cell state to <strong>output</strong></li>
                                    <li>Applied to tanh(C_t): o_t ‚äô tanh(C_t)</li>
                                    <li>This becomes the hidden state h_t</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div id="cell" class="content-section">
                        <h2>Cell State and Hidden State</h2>
                        
                        <div class="explanation-box">
                            <h3>Two-State System</h3>
                            <p><strong>LSTMs maintain two states:</strong></p>
                            <ul>
                                <li><strong>Cell State (C_t):</strong> Long-term memory (gradients flow easily)</li>
                                <li><strong>Hidden State (h_t):</strong> Short-term memory (used for predictions)</li>
                            </ul>
                        </div>

                        <div class="formula-box">
                            <h4>Cell State Update</h4>
                            
                            <div class="formula-display">
                                <strong>C_t = f_t ‚äô C_{t-1} + i_t ‚äô CÃÉ_t</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Breakdown:</h5>
                                <ul>
                                    <li><strong>f_t ‚äô C_{t-1}:</strong> What to keep from previous state</li>
                                    <li><strong>i_t ‚äô CÃÉ_t:</strong> What new information to add</li>
                                    <li><strong>Addition:</strong> Key! Gradients flow through addition</li>
                                </ul>
                            </div>
                        </div>

                        <div class="formula-box">
                            <h4>Hidden State Update</h4>
                            
                            <div class="formula-display">
                                <strong>h_t = o_t ‚äô tanh(C_t)</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Purpose:</h5>
                                <ul>
                                    <li>Hidden state is a filtered version of cell state</li>
                                    <li>Output gate controls what information to expose</li>
                                    <li>Used for predictions and next time step</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div id="formulas" class="content-section">
                        <h2>Complete LSTM Formulas</h2>
                        
                        <div class="formula-box">
                            <h4>Full LSTM Forward Pass</h4>
                            <p><strong>At each time step t:</strong></p>
                            
                            <div class="formula-display">
                                <strong>Step 1: Compute Gates</strong><br>
                                <strong>f_t = œÉ(W_f √ó [h_{t-1}, x_t] + b_f)</strong><br>
                                <strong>i_t = œÉ(W_i √ó [h_{t-1}, x_t] + b_i)</strong><br>
                                <strong>o_t = œÉ(W_o √ó [h_{t-1}, x_t] + b_o)</strong><br><br>
                                
                                <strong>Step 2: Candidate Values</strong><br>
                                <strong>CÃÉ_t = tanh(W_C √ó [h_{t-1}, x_t] + b_C)</strong><br><br>
                                
                                <strong>Step 3: Update Cell State</strong><br>
                                <strong>C_t = f_t ‚äô C_{t-1} + i_t ‚äô CÃÉ_t</strong><br><br>
                                
                                <strong>Step 4: Update Hidden State</strong><br>
                                <strong>h_t = o_t ‚äô tanh(C_t)</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Notation:</h5>
                                <ul>
                                    <li><strong>‚äô:</strong> Element-wise multiplication (Hadamard product)</li>
                                    <li><strong>[h_{t-1}, x_t]:</strong> Concatenation of hidden state and input</li>
                                    <li><strong>œÉ:</strong> Sigmoid function (outputs 0-1)</li>
                                    <li><strong>tanh:</strong> Hyperbolic tangent (outputs -1 to 1)</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div id="implementation" class="content-section">
                        <h2>LSTM Implementation</h2>
                        
                        <div class="code-box">
                            <h4>Complete LSTM Implementation</h4>
                            <pre><code class="language-python">import numpy as np

class LSTM:
    """Long Short-Term Memory Network"""
    
    def __init__(self, input_size, hidden_size):
        self.input_size = input_size
        self.hidden_size = hidden_size
        
        # Weight matrices for forget gate
        self.W_f = np.random.randn(hidden_size, hidden_size + input_size) * 0.1
        self.b_f = np.zeros((hidden_size, 1))
        
        # Weight matrices for input gate
        self.W_i = np.random.randn(hidden_size, hidden_size + input_size) * 0.1
        self.b_i = np.zeros((hidden_size, 1))
        
        # Weight matrices for candidate values
        self.W_C = np.random.randn(hidden_size, hidden_size + input_size) * 0.1
        self.b_C = np.zeros((hidden_size, 1))
        
        # Weight matrices for output gate
        self.W_o = np.random.randn(hidden_size, hidden_size + input_size) * 0.1
        self.b_o = np.zeros((hidden_size, 1))
    
    def sigmoid(self, x):
        return 1 / (1 + np.exp(-np.clip(x, -250, 250)))
    
    def tanh(self, x):
        return np.tanh(x)
    
    def forward_step(self, x, h_prev, C_prev):
        """One LSTM forward step"""
        # Concatenate hidden state and input
        concat = np.vstack([h_prev, x])
        
        # Forget gate
        f_t = self.sigmoid(np.dot(self.W_f, concat) + self.b_f)
        
        # Input gate
        i_t = self.sigmoid(np.dot(self.W_i, concat) + self.b_i)
        
        # Candidate values
        C_tilde = self.tanh(np.dot(self.W_C, concat) + self.b_C)
        
        # Update cell state
        C_t = f_t * C_prev + i_t * C_tilde
        
        # Output gate
        o_t = self.sigmoid(np.dot(self.W_o, concat) + self.b_o)
        
        # Update hidden state
        h_t = o_t * self.tanh(C_t)
        
        return h_t, C_t
    
    def forward(self, sequence):
        """Forward pass through sequence"""
        h = np.zeros((self.hidden_size, 1))
        C = np.zeros((self.hidden_size, 1))
        outputs = []
        
        for x in sequence:
            h, C = self.forward_step(x, h, C)
            outputs.append(h)
        
        return outputs

# Example usage
lstm = LSTM(input_size=10, hidden_size=20)
sequence = [np.random.randn(10, 1) for _ in range(5)]
outputs = lstm.forward(sequence)
print(f"Processed {len(outputs)} time steps")</code></pre>
                        </div>
                    </div>

                    <div id="quiz" class="content-section">
                        <h2>Test Your Understanding</h2>
                        
                        <div class="quiz-container">
                            <div class="quiz-question">
                                <h3>Question 1: How do LSTMs solve the vanishing gradient problem?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) By using fewer layers</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">B) By using additive updates to cell state instead of multiplicative</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) By removing hidden states</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) By using larger learning rates</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 2: What does the forget gate do?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Decides what information to forget from the cell state</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Removes all previous information</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Controls the output</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Adds new information</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 3: What is the difference between cell state and hidden state?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Cell state is long-term memory, hidden state is short-term memory used for predictions</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) They are the same thing</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Cell state is input, hidden state is output</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) There is no difference</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 4: How does the forget gate work in an LSTM?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) The forget gate decides what information to discard from the cell state by outputting values between 0 and 1, where 0 means completely forget and 1 means keep everything</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) It forgets everything</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) It remembers everything</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) It only works on inputs</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 5: What is the purpose of the cell state in LSTM?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) The cell state acts as a highway for information to flow through the sequence with minimal modification, allowing gradients to flow better and enabling long-term memory</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) It stores only current input</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) It's the same as hidden state</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) It's not important</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 6: How does LSTM solve the vanishing gradient problem better than basic RNNs?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) The cell state provides a direct path for gradients to flow through time with minimal multiplication, and the gates allow selective information flow, preventing gradients from vanishing as they propagate backward</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) It doesn't solve it</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) By using more layers</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) By using fewer parameters</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 7: What is the difference between LSTM and GRU?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) LSTM has separate forget and input gates with a cell state, while GRU combines forget and input gates into a single update gate and merges cell state with hidden state, making GRU simpler and faster but sometimes less powerful</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) They're identical</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) GRU is always better</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) LSTM has no gates</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 8: How do you compute the LSTM output at each time step?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) The output gate filters the cell state using a sigmoid, then the filtered cell state is passed through tanh to produce the hidden state, which becomes the output</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Just use cell state directly</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Use only input</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Random value</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 9: When would you choose LSTM over a basic RNN?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) When you need to learn long-term dependencies in sequences, when basic RNNs struggle with vanishing gradients, or when task requires remembering information over many time steps</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Always use basic RNN</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Only for short sequences</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) They're interchangeable</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 10: What is the computational cost of LSTM compared to basic RNN?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) LSTM is more expensive due to multiple gates and the cell state, requiring more parameters and computations per time step, but often worth it for better performance on long sequences</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) LSTM is faster</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) They're the same</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) LSTM uses fewer parameters</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 11: How does the input gate decide what new information to store?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) The input gate uses a sigmoid to decide which values to update, then a tanh creates candidate values, and these are combined to update the cell state selectively</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) It stores everything</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) It stores nothing</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Random selection</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 12: How would you implement an LSTM cell from scratch?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Implement forget gate (sigmoid of weighted sum), input gate (sigmoid), candidate values (tanh), update cell state (forget old, add new), output gate (sigmoid), compute hidden state (output gate times tanh of cell state). Each gate has its own weight matrices</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) Just copy RNN code</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Use only one gate</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) No implementation needed</div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </section>
    </main>

    <footer style="background: #f8f9fa; padding: 2rem 0; margin-top: 3rem; border-top: 2px solid #5B7553;">
        <div class="azbn-container" style="text-align: center;">
            <button onclick="scrollToSectionNav()" class="azbn-btn" style="margin: 0.5rem;">
                ‚Üë Back to Section Navigation
            </button>
            <div style="margin-top: 1.5rem;">
                <a href="/tutorials/neural-networks" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Back to Tutorial</a>
                <a href="/tutorials/neural-networks/chapter6" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Chapter 6</a>
                <a href="/tutorials/neural-networks/chapter8" class="azbn-btn" style="text-decoration: none; margin: 0.5rem;">Chapter 8: Training Tips ‚Üí</a>
            </div>
        </div>
    </footer>
    
        <!-- KaTeX for math rendering -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
    <script src="{{ url_for('static', filename='js/tutorials/neural-networks/shared-tutorial.js') }}"></script>
    <script>
        function scrollToSectionNav() {
            const sectionNav = document.querySelector('.section-nav');
            if (sectionNav) {
                sectionNav.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        function checkAnswer(element, isCorrect) {
            element.parentNode.querySelectorAll('.quiz-option').forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
            });
            if (isCorrect) {
                element.classList.add('correct');
                element.textContent += ' ‚úì Correct!';
            } else {
                element.classList.add('incorrect');
                element.textContent += ' ‚úó Incorrect';
                const correctOption = Array.from(element.parentNode.querySelectorAll('.quiz-option'))
                    .find(opt => {
                        const onclick = opt.getAttribute('onclick') || '';
                        return onclick.includes('true');
                    });
                if (correctOption && !correctOption.classList.contains('incorrect')) {
                    correctOption.classList.add('correct');
                    correctOption.textContent += ' ‚úì Correct Answer';
                }
            }
        }
            
        // Initialize KaTeX rendering
        document.addEventListener("DOMContentLoaded", function() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: "$$", right: "$$", display: true},
                        {left: "\[", right: "\]", display: true},
                        {left: "$", right: "$", display: false},
                        {left: "\(", right: "\)", display: false}
                    ],
                    throwOnError: false
                });
            }
            
            // Initialize Prism.js syntax highlighting
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>
