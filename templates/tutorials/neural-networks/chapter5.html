<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: Convolutional Neural Networks (CNNs) - Neural Networks Fundamentals</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/tutorials/neural-networks/neural-networks.css') }}">
</head>
<body>
    <header class="azbn-header">
        <nav class="azbn-nav">
            <div class="azbn-container">
                <a href="/tutorials/neural-networks" class="course-link">
                    <span>Neural Networks Fundamentals</span>
                </a>
                <div class="azbn-links">
                    <a href="/">Home</a>
                    <a href="/#about">About</a>
                    <a href="/tutorials/">Tutorials</a>
                    <a href="/#projects">Projects</a>
                    <a href="/contact">Contact</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        <div class="tutorial-header">
            <div class="azbn-container">
                <h1 class="chapter-title">Chapter 5: Convolutional Neural Networks (CNNs)</h1>
                <p class="chapter-subtitle">Specialized networks for image processing and spatial data</p>
                
                <div class="chapter-progress">
                    <div class="chapter-progress-fill" data-progress="62.5"></div>
                </div>
                
                <div class="chapter-navigation">
                    <a href="/tutorials/neural-networks/chapter1" class="chapter-nav-btn">Chapter 1</a>
                    <a href="/tutorials/neural-networks/chapter2" class="chapter-nav-btn">Chapter 2</a>
                    <a href="/tutorials/neural-networks/chapter3" class="chapter-nav-btn">Chapter 3</a>
                    <a href="/tutorials/neural-networks/chapter4" class="chapter-nav-btn">Chapter 4</a>
                    <a href="/tutorials/neural-networks/chapter5" class="chapter-nav-btn active">Chapter 5</a>
                    <a href="/tutorials/neural-networks/chapter6" class="chapter-nav-btn">Chapter 6</a>
                    <a href="/tutorials/neural-networks/chapter7" class="chapter-nav-btn">Chapter 7</a>
                    <a href="/tutorials/neural-networks/chapter8" class="chapter-nav-btn">Chapter 8</a>
                </div>
                
                <div class="section-progress">
                    <div class="section-progress-fill" data-progress="14.3"></div>
                </div>
                
                <div class="section-nav">
                    <button class="section-nav-btn azbn-btn active" data-section="overview">Overview</button>
                    <button class="section-nav-btn azbn-btn" data-section="convolution">Convolution Operation</button>
                    <button class="section-nav-btn azbn-btn" data-section="pooling">Pooling Layers</button>
                    <button class="section-nav-btn azbn-btn" data-section="architecture">CNN Architecture</button>
                    <button class="section-nav-btn azbn-btn" data-section="backprop">Backpropagation in CNNs</button>
                    <button class="section-nav-btn azbn-btn" data-section="implementation">Implementation</button>
                    <button class="section-nav-btn azbn-btn" data-section="quiz">Quiz</button>
                </div>
            </div>
        </div>

        <section class="azbn-section">
            <div class="azbn-container">
                <div class="learning-objectives-box">
                    <h2>Learning Objectives</h2>
                    <ul>
                        <li>Understand the convolution operation and its purpose</li>
                        <li>Master pooling layers and their role in CNNs</li>
                        <li>Learn complete CNN architecture</li>
                        <li>Understand backpropagation in convolutional layers</li>
                        <li>Implement a CNN from scratch</li>
                        <li>Recognize when to use CNNs vs MLPs</li>
                    </ul>
                </div>

                <main class="chapter-main-content">
                    <div id="overview" class="content-section active">
                        <h2>What are Convolutional Neural Networks?</h2>
                        
                        <div class="explanation-box">
                            <h3>üñºÔ∏è Specialized for Images</h3>
                            <p><strong>Convolutional Neural Networks (CNNs) are specialized neural networks designed for processing grid-like data such as images.</strong> Unlike fully connected networks, CNNs use convolution operations to automatically learn spatial hierarchies of features.</p>
                            
                            <p><strong>Think of CNNs like a detective examining a crime scene photo:</strong></p>
                            <ul>
                                <li><strong>Traditional Networks:</strong> Like trying to understand the entire photo at once - overwhelming and inefficient</li>
                                <li><strong>CNNs:</strong> Like examining small patches with a magnifying glass, looking for specific patterns (edges, textures, shapes) that appear throughout the image</li>
                                <li><strong>Key Insight:</strong> The same pattern (like an edge or corner) can appear anywhere in an image, so we use the same "detective tool" (filter) everywhere</li>
                            </ul>
                        </div>

                        <div class="example-box">
                            <h4>üìö Why CNNs for Images? The Fundamental Problem</h4>
                            <p><strong>Problem with MLPs (Multi-Layer Perceptrons) for images:</strong></p>
                            
                            <div class="explanation-box">
                                <h5>The Parameter Explosion Problem</h5>
                                <p>Consider a simple 28√ó28 grayscale image (like MNIST digits):</p>
                                <ul>
                                    <li><strong>28√ó28 image = 784 pixels</strong> = 784 input neurons</li>
                                    <li><strong>Fully connected to 100 hidden neurons</strong> = 784 √ó 100 = <strong>78,400 weights!</strong></li>
                                    <li><strong>Plus biases:</strong> 100 more parameters</li>
                                    <li><strong>Total for just one layer:</strong> 78,500 parameters</li>
                                </ul>
                                
                                <p><strong>For a color image (224√ó224√ó3):</strong></p>
                                <ul>
                                    <li>224√ó224√ó3 = 150,528 input neurons</li>
                                    <li>Connected to 1000 hidden neurons = <strong>150,528,000 weights!</strong></li>
                                    <li>This is computationally impossible and leads to overfitting</li>
                                </ul>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>The Spatial Relationship Problem</h5>
                                <p><strong>MLPs treat images as flat lists of numbers:</strong></p>
                                <ul>
                                    <li>They have <strong>no understanding</strong> that pixel (5,10) is next to pixel (6,10)</li>
                                    <li>A pattern in the top-left corner requires <strong>completely different weights</strong> than the same pattern in the bottom-right</li>
                                    <li>This means the network must <strong>relearn the same pattern</strong> for every possible position</li>
                                    <li>Like teaching someone to recognize a cat, but they have to learn it separately for every possible location in a photo!</li>
                                </ul>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>The CNN Solution: Three Key Innovations</h5>
                                <p><strong>1. Local Receptive Fields (Convolution):</strong></p>
                                <ul>
                                    <li>Instead of connecting every pixel to every neuron, we use <strong>small filters (e.g., 3√ó3 or 5√ó5)</strong></li>
                                    <li>Each filter scans the entire image, looking for the same pattern everywhere</li>
                                    <li>Like using the same magnifying glass to look for fingerprints throughout the crime scene</li>
                                    <li><strong>Result:</strong> One filter can detect edges, corners, or textures anywhere in the image</li>
                                </ul>
                                
                                <p><strong>2. Parameter Sharing:</strong></p>
                                <ul>
                                    <li>The same filter weights are used at every position in the image</li>
                                    <li>If a 3√ó3 filter has 9 weights, those same 9 weights work everywhere</li>
                                    <li><strong>Example:</strong> Instead of 78,400 weights, we might have 32 filters √ó 9 weights = 288 weights!</li>
                                    <li>This is a <strong>massive reduction</strong> in parameters</li>
                                </ul>
                                
                                <p><strong>3. Hierarchical Feature Learning:</strong></p>
                                <ul>
                                    <li><strong>Early layers:</strong> Learn simple features (edges, corners, lines)</li>
                                    <li><strong>Middle layers:</strong> Combine simple features into shapes (circles, rectangles, curves)</li>
                                    <li><strong>Deep layers:</strong> Combine shapes into complex objects (faces, cars, buildings)</li>
                                    <li>Like building a pyramid: start with small blocks (edges), build into larger structures (shapes), then complete objects</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-box">
                            <h4>üéØ Real-World Analogy: The CNN Detective</h4>
                            <p><strong>Imagine a detective analyzing a crime scene photo:</strong></p>
                            <ul>
                                <li><strong>Traditional Network:</strong> Tries to understand the entire photo at once - too much information, misses details</li>
                                <li><strong>CNN Approach:</strong>
                                    <ul>
                                        <li><strong>Step 1:</strong> Uses a small magnifying glass (3√ó3 filter) to scan the entire photo, looking for specific patterns (edges, textures)</li>
                                        <li><strong>Step 2:</strong> Combines findings from multiple scans to identify larger patterns (shapes, objects)</li>
                                        <li><strong>Step 3:</strong> Combines these larger patterns to understand the scene (people, objects, relationships)</li>
                                    </ul>
                                </li>
                                <li><strong>Key Advantage:</strong> The same magnifying glass (filter) works everywhere - if it finds an edge in the top-left, it can find the same type of edge in the bottom-right using the same tool</li>
                            </ul>
                        </div>

                        <div class="formula-box">
                            <h4>Mathematical Intuition</h4>
                            <p><strong>Why convolution works for images:</strong></p>
                            
                            <div class="formula-explanation">
                                <h5>Convolution as Pattern Matching</h5>
                                <p>Convolution is essentially <strong>pattern matching</strong>:</p>
                                <ul>
                                    <li>We slide a small template (filter) across the image</li>
                                    <li>At each position, we compute how well the template matches that region</li>
                                    <li>High match = strong activation = "this pattern is here!"</li>
                                    <li>Low match = weak activation = "this pattern is not here"</li>
                                </ul>
                                
                                <p><strong>This is exactly what our visual system does:</strong></p>
                                <ul>
                                    <li>Our eyes have edge detectors (like certain CNN filters)</li>
                                    <li>These detectors work the same way regardless of where we look</li>
                                    <li>CNNs mimic this biological process!</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div id="convolution" class="content-section">
                        <h2>The Convolution Operation</h2>
                        
                        <div class="explanation-box">
                            <h3>üîç Sliding Window Filter</h3>
                            <p><strong>Convolution is a mathematical operation that applies a filter (kernel) to an input image by sliding it across the image and computing element-wise products.</strong></p>
                            
                            <p><strong>Think of convolution like using a stencil or template:</strong></p>
                            <ul>
                                <li><strong>Image:</strong> A large piece of paper with a pattern</li>
                                <li><strong>Filter/Kernel:</strong> A small transparent stencil with a specific pattern</li>
                                <li><strong>Process:</strong> Place the stencil at different positions, see how well it matches, record the match score</li>
                                <li><strong>Result:</strong> A new "map" showing where the pattern appears in the original image</li>
                            </ul>
                            
                            <p><strong>Real-world analogy:</strong> Like using a cookie cutter (filter) on dough (image) - you press it down at different positions to find where the pattern matches best!</p>
                        </div>

                        <div class="explanation-box">
                            <h4>üéØ Why Convolution Works: The Intuition</h4>
                            <p><strong>Convolution works because images have local patterns that repeat:</strong></p>
                            <ul>
                                <li><strong>Edges:</strong> The transition from dark to light appears many times in an image</li>
                                <li><strong>Textures:</strong> Patterns like wood grain, fabric weave, or brick patterns repeat</li>
                                <li><strong>Shapes:</strong> Corners, curves, and lines appear in different locations</li>
                            </ul>
                            <p><strong>Key Insight:</strong> Instead of learning to detect an edge at position (10, 20) separately from an edge at position (50, 100), we learn ONE edge detector that works everywhere!</p>
                        </div>

                        <div class="formula-box">
                            <h4>Convolution Formula</h4>
                            <p>For a 2D convolution:</p>
                            
                            <div class="formula-display">
                                <strong>(I * K)[i, j] = Œ£‚Çò Œ£‚Çô I[i+m, j+n] √ó K[m, n]</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Notation:</h5>
                                <ul>
                                    <li><strong>I:</strong> Input image (matrix)</li>
                                    <li><strong>K:</strong> Kernel/filter (small matrix, e.g., 3√ó3)</li>
                                    <li><strong>*:</strong> Convolution operator</li>
                                    <li><strong>[i, j]:</strong> Output position</li>
                                    <li><strong>m, n:</strong> Kernel indices</li>
                                </ul>
                            </div>
                        </div>

                        <div class="example-box">
                            <h4>üî¢ Detailed Step-by-Step Example with Visual Diagram</h4>
                            <p><strong>Let's work through a complete convolution example:</strong></p>
                            
                            <div class="explanation-box">
                                <h5>Step 1: Our Input Image (5√ó5)</h5>
                                <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border: 2px solid #0ea5e9; border-radius: 12px; padding: 2rem; margin: 1.5rem 0; text-align: center;">
                                    <h4 style="color: #0c4a6e; margin-bottom: 1rem;">üìä Input Image Visualization</h4>
                                    <div style="display: inline-block; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                        <table style="border-collapse: collapse; margin: 0 auto; font-family: 'JetBrains Mono', monospace; font-size: 1.1rem;">
                                            <tr>
                                                <td style="padding: 0.5rem; background: #dbeafe; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">1</td>
                                                <td style="padding: 0.5rem; background: #bfdbfe; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">2</td>
                                                <td style="padding: 0.5rem; background: #a5b4fc; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">3</td>
                                                <td style="padding: 0.5rem; background: #8b5cf6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">4</td>
                                                <td style="padding: 0.5rem; background: #7c3aed; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">5</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.5rem; background: #bfdbfe; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">6</td>
                                                <td style="padding: 0.5rem; background: #a5b4fc; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">7</td>
                                                <td style="padding: 0.5rem; background: #8b5cf6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">8</td>
                                                <td style="padding: 0.5rem; background: #7c3aed; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">9</td>
                                                <td style="padding: 0.5rem; background: #6d28d9; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">10</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.5rem; background: #a5b4fc; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">11</td>
                                                <td style="padding: 0.5rem; background: #8b5cf6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">12</td>
                                                <td style="padding: 0.5rem; background: #7c3aed; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">13</td>
                                                <td style="padding: 0.5rem; background: #6d28d9; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">14</td>
                                                <td style="padding: 0.5rem; background: #5b21b6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">15</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.5rem; background: #8b5cf6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">16</td>
                                                <td style="padding: 0.5rem; background: #7c3aed; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">17</td>
                                                <td style="padding: 0.5rem; background: #6d28d9; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">18</td>
                                                <td style="padding: 0.5rem; background: #5b21b6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">19</td>
                                                <td style="padding: 0.5rem; background: #4c1d95; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">20</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.5rem; background: #7c3aed; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">21</td>
                                                <td style="padding: 0.5rem; background: #6d28d9; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">22</td>
                                                <td style="padding: 0.5rem; background: #5b21b6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">23</td>
                                                <td style="padding: 0.5rem; background: #4c1d95; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">24</td>
                                                <td style="padding: 0.5rem; background: #3b1a7a; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">25</td>
                                            </tr>
                                        </table>
                                    </div>
                                    <p style="margin-top: 1rem; color: #0c4a6e; font-style: italic;">This represents a simple gradient image where values increase from top-left to bottom-right. Darker colors = higher values.</p>
                                </div>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>Step 2: Our Filter/Kernel (3√ó3) - Edge Enhancement</h5>
                                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 12px; padding: 2rem; margin: 1.5rem 0; text-align: center;">
                                    <h4 style="color: #92400e; margin-bottom: 1rem;">üîç Filter/Kernel Visualization</h4>
                                    <div style="display: inline-block; background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                        <table style="border-collapse: collapse; margin: 0 auto; font-family: 'JetBrains Mono', monospace; font-size: 1.1rem;">
                                            <tr>
                                                <td style="padding: 0.5rem; background: #fee2e2; border: 2px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">0</td>
                                                <td style="padding: 0.5rem; background: #fee2e2; border: 2px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-1</td>
                                                <td style="padding: 0.5rem; background: #fee2e2; border: 2px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">0</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.5rem; background: #fee2e2; border: 2px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-1</td>
                                                <td style="padding: 0.5rem; background: #dcfce7; border: 3px solid #22c55e; text-align: center; font-weight: 700; color: #166534; font-size: 1.2rem;">5</td>
                                                <td style="padding: 0.5rem; background: #fee2e2; border: 2px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-1</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 0.5rem; background: #fee2e2; border: 2px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">0</td>
                                                <td style="padding: 0.5rem; background: #fee2e2; border: 2px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-1</td>
                                                <td style="padding: 0.5rem; background: #fee2e2; border: 2px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">0</td>
                                            </tr>
                                        </table>
                                    </div>
                                    <div style="margin-top: 1rem; text-align: left; background: white; padding: 1rem; border-radius: 8px;">
                                        <p style="color: #92400e; font-weight: 600; margin-bottom: 0.5rem;">What this filter does:</p>
                                        <ul style="color: #78350f; margin: 0; padding-left: 1.5rem;">
                                            <li><strong style="color: #166534;">Center value (5)</strong> - amplifies the center pixel</li>
                                            <li><strong style="color: #991b1b;">Surrounding values (-1)</strong> - subtracts neighboring pixels</li>
                                            <li>Creates a <strong>sharpening effect</strong> - makes edges more pronounced</li>
                                            <li>If center is much brighter than neighbors ‚Üí high output (edge detected!)</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>Step 3: Convolution at Position (1,1) - Visual Convolution Operation</h5>
                                <p><strong>We place the filter at the top-left corner and slide it across:</strong></p>
                                
                                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #22c55e; border-radius: 12px; padding: 2rem; margin: 1.5rem 0;">
                                    <h4 style="color: #14532d; margin-bottom: 1rem; text-align: center;">üîÑ Convolution Operation Visualization</h4>
                                    
                                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 2rem; margin: 2rem 0;">
                                        <div style="text-align: center;">
                                            <p style="font-weight: 600; color: #14532d; margin-bottom: 0.5rem;">Image Region</p>
                                            <div style="background: white; padding: 1rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                                <table style="border-collapse: collapse; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem;">
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #dbeafe; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">1</td>
                                                        <td style="padding: 0.4rem; background: #bfdbfe; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">2</td>
                                                        <td style="padding: 0.4rem; background: #a5b4fc; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">3</td>
                                                    </tr>
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #bfdbfe; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">6</td>
                                                        <td style="padding: 0.4rem; background: #a5b4fc; border: 2px solid #22c55e; text-align: center; font-weight: 700; color: #166534;">7</td>
                                                        <td style="padding: 0.4rem; background: #8b5cf6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">8</td>
                                                    </tr>
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #a5b4fc; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">11</td>
                                                        <td style="padding: 0.4rem; background: #8b5cf6; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">12</td>
                                                        <td style="padding: 0.4rem; background: #7c3aed; border: 1px solid #93c5fd; text-align: center; font-weight: 600;">13</td>
                                                    </tr>
                                                </table>
                                            </div>
                                        </div>
                                        
                                        <div style="font-size: 2rem; color: #22c55e; font-weight: bold;">√ó</div>
                                        
                                        <div style="text-align: center;">
                                            <p style="font-weight: 600; color: #14532d; margin-bottom: 0.5rem;">Filter/Kernel</p>
                                            <div style="background: white; padding: 1rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                                <table style="border-collapse: collapse; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem;">
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">0</td>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-1</td>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">0</td>
                                                    </tr>
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-1</td>
                                                        <td style="padding: 0.4rem; background: #dcfce7; border: 2px solid #22c55e; text-align: center; font-weight: 700; color: #166534;">5</td>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-1</td>
                                                    </tr>
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">0</td>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-1</td>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">0</td>
                                                    </tr>
                                                </table>
                                            </div>
                                        </div>
                                        
                                        <div style="font-size: 2rem; color: #22c55e; font-weight: bold;">=</div>
                                        
                                        <div style="text-align: center;">
                                            <p style="font-weight: 600; color: #14532d; margin-bottom: 0.5rem;">Element-wise Product</p>
                                            <div style="background: white; padding: 1rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                                                <table style="border-collapse: collapse; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem;">
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #f3f4f6; border: 1px solid #d1d5db; text-align: center; font-weight: 600;">0</td>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-2</td>
                                                        <td style="padding: 0.4rem; background: #f3f4f6; border: 1px solid #d1d5db; text-align: center; font-weight: 600;">0</td>
                                                    </tr>
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-6</td>
                                                        <td style="padding: 0.4rem; background: #dcfce7; border: 2px solid #22c55e; text-align: center; font-weight: 700; color: #166534; font-size: 1.1rem;">35</td>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-8</td>
                                                    </tr>
                                                    <tr>
                                                        <td style="padding: 0.4rem; background: #f3f4f6; border: 1px solid #d1d5db; text-align: center; font-weight: 600;">0</td>
                                                        <td style="padding: 0.4rem; background: #fee2e2; border: 1px solid #ef4444; text-align: center; font-weight: 600; color: #991b1b;">-12</td>
                                                        <td style="padding: 0.4rem; background: #f3f4f6; border: 1px solid #d1d5db; text-align: center; font-weight: 600;">0</td>
                                                    </tr>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="background: white; padding: 1.5rem; border-radius: 8px; margin-top: 1.5rem; text-align: center;">
                                        <p style="font-weight: 600; color: #14532d; margin-bottom: 0.5rem;">Sum all values:</p>
                                        <p style="font-family: 'JetBrains Mono', monospace; font-size: 1.1rem; color: #166534; font-weight: 600;">
                                            Output[1,1] = 0 + (-2) + 0 + (-6) + <span style="background: #dcfce7; padding: 0.2rem 0.5rem; border-radius: 4px; font-weight: 700;">35</span> + (-8) + 0 + (-12) + 0 = <strong style="color: #166534; font-size: 1.2rem;">7</strong>
                                        </p>
                                        <p style="margin-top: 0.5rem; color: #166534; font-style: italic;">The center pixel (7) is amplified by 5√ó, neighbors are subtracted ‚Üí Result: 7 (edge preserved!)</p>
                                    </div>
                                </div>
                                
                                <div style="background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 1rem; margin: 1rem 0; border-radius: 4px;">
                                    <p style="margin: 0; color: #0c4a6e;"><strong>üí° Key Insight:</strong> The filter slides across the entire image, computing this operation at every position. This creates a feature map showing where edges (or other patterns) appear!</p>
                                </div>
                                <p>Output[1,1] = 0 - 2 - 6 + 35 - 8 - 12 = <strong>7</strong></p>
                                
                                <p><strong>Interpretation:</strong> The center pixel (7) is slightly brighter than its neighbors, so we get a positive but small output. This indicates a weak edge.</p>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>Step 4: Convolution at Position (2,2) - Stronger Edge</h5>
                                <p><strong>Now let's check position (2,2) where we have a stronger transition:</strong></p>
                                
                                <p><strong>Image region:</strong></p>
                                <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px; font-family: 'JetBrains Mono', monospace;">
[7   8   9 ]
[12  13  14]
[17  18  19]</pre>
                                
                                <p><strong>Element-wise multiplication:</strong></p>
                                <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px; font-family: 'JetBrains Mono', monospace;">
[7√ó0   8√ó(-1)  9√ó0 ]   [0   -8   0 ]
[12√ó(-1) 13√ó5  14√ó(-1)] = [-12  65  -14]
[17√ó0  18√ó(-1) 19√ó0]   [0  -18   0]</pre>
                                
                                <p><strong>Sum:</strong></p>
                                <p>Output[2,2] = 0 - 8 - 12 + 65 - 14 - 18 = <strong>13</strong></p>
                                
                                <p><strong>Interpretation:</strong> Higher output (13 vs 7) means a stronger edge detected! The center pixel (13) is more distinct from its neighbors.</p>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>üéØ Key Takeaways from This Example</h5>
                                <ul>
                                    <li><strong>Convolution measures local patterns:</strong> It compares each pixel to its neighbors</li>
                                    <li><strong>High output = strong pattern match:</strong> When the filter pattern matches the image region, output is high</li>
                                    <li><strong>Low output = weak pattern match:</strong> When the pattern doesn't match, output is low</li>
                                    <li><strong>Same filter, different positions:</strong> We use the SAME filter everywhere, but get different outputs based on what's in the image</li>
                                </ul>
                            </div>
                        </div>

                        <div class="code-box">
                            <h4>üíª Convolution Implementation</h4>
                            <pre><code>import numpy as np

def convolve2d(image, kernel, stride=1, padding=0):
    """
    2D Convolution operation
    
    Parameters:
    image: Input image (H, W)
    kernel: Filter/kernel (K_h, K_w)
    stride: Step size for sliding
    padding: Zero padding size
    """
    # Add padding
    if padding > 0:
        image = np.pad(image, padding, mode='constant')
    
    # Get dimensions
    img_h, img_w = image.shape
    kernel_h, kernel_w = kernel.shape
    
    # Calculate output dimensions
    out_h = (img_h - kernel_h) // stride + 1
    out_w = (img_w - kernel_w) // stride + 1
    
    # Initialize output
    output = np.zeros((out_h, out_w))
    
    # Perform convolution
    for i in range(0, out_h):
        for j in range(0, out_w):
            # Extract region
            region = image[i*stride:i*stride+kernel_h, 
                          j*stride:j*stride+kernel_w]
            # Element-wise multiplication and sum
            output[i, j] = np.sum(region * kernel)
    
    return output

# Example: Edge detection
image = np.array([[1, 2, 3, 4],
                  [5, 6, 7, 8],
                  [9, 10, 11, 12],
                  [13, 14, 15, 16]])

# Vertical edge detector
kernel = np.array([[-1, 0, 1],
                   [-1, 0, 1],
                   [-1, 0, 1]])

result = convolve2d(image, kernel)
print("Convolution result:\n", result)</code></pre>
                        </div>
                    </div>

                    <div id="pooling" class="content-section">
                        <h2>Pooling Layers</h2>
                        
                        <div class="explanation-box">
                            <h3>üìâ Downsampling Operation</h3>
                            <p><strong>Pooling layers reduce the spatial dimensions of feature maps, making the network more efficient and providing translation invariance.</strong> Common types include max pooling and average pooling.</p>
                            
                            <p><strong>Think of pooling like creating a summary or thumbnail:</strong></p>
                            <ul>
                                <li><strong>Before pooling:</strong> You have a detailed 1000√ó1000 pixel photo with every detail</li>
                                <li><strong>After pooling:</strong> You create a 500√ó500 thumbnail that captures the most important information</li>
                                <li><strong>Key benefit:</strong> The thumbnail is much smaller (faster to process) but still contains the essential features</li>
                                <li><strong>Real-world analogy:</strong> Like creating a summary of a long document - you keep the most important points, discard the details</li>
                            </ul>
                        </div>

                        <div class="explanation-box">
                            <h4>üéØ Why Do We Need Pooling?</h4>
                            <p><strong>Three critical reasons:</strong></p>
                            
                            <div class="explanation-box">
                                <h5>1. Computational Efficiency</h5>
                                <p><strong>Problem:</strong> After convolution, feature maps can be very large</p>
                                <ul>
                                    <li>Input: 224√ó224 image</li>
                                    <li>After first conv layer: 224√ó224√ó64 (64 feature maps!)</li>
                                    <li>This is <strong>3.2 million values</strong> to process</li>
                                    <li>Each subsequent layer would be even larger without pooling</li>
                                </ul>
                                <p><strong>Solution:</strong> Max pooling reduces 224√ó224 to 112√ó112</p>
                                <ul>
                                    <li>Now we have <strong>800,000 values</strong> - 4√ó reduction!</li>
                                    <li>Much faster computation</li>
                                    <li>Less memory required</li>
                                </ul>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>2. Translation Invariance</h5>
                                <p><strong>Problem:</strong> An object might appear at slightly different positions</p>
                                <ul>
                                    <li>A cat's face might be at pixel (100, 150) in one image</li>
                                    <li>Same cat's face at pixel (102, 152) in another image</li>
                                    <li>Without pooling, these are treated as completely different!</li>
                                </ul>
                                <p><strong>Solution:</strong> Max pooling makes the network less sensitive to small shifts</p>
                                <ul>
                                    <li>If an edge is detected anywhere in a 2√ó2 region, max pooling keeps it</li>
                                    <li>The network learns: "edge detected in this general area" not "edge at exact pixel (100, 150)"</li>
                                    <li>This makes the network more robust to object position</li>
                                </ul>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>3. Feature Abstraction</h5>
                                <p><strong>Problem:</strong> Early layers detect very specific, local features</p>
                                <ul>
                                    <li>Layer 1 might detect: "vertical edge at position (50, 75)"</li>
                                    <li>Layer 1 might detect: "vertical edge at position (50, 76)"</li>
                                    <li>These are essentially the same feature, but treated separately</li>
                                </ul>
                                <p><strong>Solution:</strong> Pooling combines nearby detections</p>
                                <ul>
                                    <li>After pooling: "vertical edge in this region"</li>
                                    <li>This abstraction helps later layers build more complex features</li>
                                    <li>Like zooming out to see the bigger picture</li>
                                </ul>
                            </div>
                        </div>

                        <div class="formula-box">
                            <h4>Max Pooling</h4>
                            <p><strong>Takes the maximum value in each pooling window:</strong></p>
                            
                            <div class="formula-display">
                                <strong>Output[i, j] = max(Input[i√ós : i√ós+p, j√ós : j√ós+p])</strong>
                            </div>
                            
                            <p>Where <strong>s</strong> is stride and <strong>p</strong> is pool size</p>
                            
                            <div class="formula-explanation">
                                <h5>Why Max Pooling?</h5>
                                <ul>
                                    <li><strong>Reduces computation:</strong> Smaller feature maps</li>
                                    <li><strong>Translation invariance:</strong> Detects features regardless of exact position</li>
                                    <li><strong>Preserves strongest activations:</strong> Keeps most important features</li>
                                </ul>
                            </div>
                        </div>

                        <div class="example-box">
                            <h4>üî¢ Detailed Max Pooling Example</h4>
                            <p><strong>Let's work through a complete max pooling operation:</strong></p>
                            
                            <div class="explanation-box">
                                <h5>Step 1: Our Input Feature Map (4√ó4)</h5>
                                <p><strong>This represents activations from a convolutional layer:</strong></p>
                                <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px; font-family: 'JetBrains Mono', monospace;">
[1   3   2   4 ]
[5   7   6   8 ]
[9   11  10  12]
[13  15  14  16]</pre>
                                <p><strong>Interpretation:</strong> Each value represents how strongly a feature (like an edge) was detected at that location. Higher values = stronger detection.</p>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>Step 2: Max Pooling with 2√ó2 Window, Stride=2</h5>
                                <p><strong>We divide the 4√ó4 map into non-overlapping 2√ó2 regions:</strong></p>
                                
                                <p><strong>Region 1 (Top-Left):</strong></p>
                                <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px; font-family: 'JetBrains Mono', monospace;">
[1   3]
[5   7]</pre>
                                <p>Max value: <strong>max(1, 3, 5, 7) = 7</strong></p>
                                <p><strong>Meaning:</strong> The strongest feature activation in this region is 7. We keep this value and discard the others (1, 3, 5).</p>
                                
                                <p><strong>Region 2 (Top-Right):</strong></p>
                                <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px; font-family: 'JetBrains Mono', monospace;">
[2   4]
[6   8]</pre>
                                <p>Max value: <strong>max(2, 4, 6, 8) = 8</strong></p>
                                
                                <p><strong>Region 3 (Bottom-Left):</strong></p>
                                <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px; font-family: 'JetBrains Mono', monospace;">
[9   11]
[13  15]</pre>
                                <p>Max value: <strong>max(9, 11, 13, 15) = 15</strong></p>
                                
                                <p><strong>Region 4 (Bottom-Right):</strong></p>
                                <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px; font-family: 'JetBrains Mono', monospace;">
[10  12]
[14  16]</pre>
                                <p>Max value: <strong>max(10, 12, 14, 16) = 16</strong></p>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>Step 3: Final Output (2√ó2)</h5>
                                <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px; font-family: 'JetBrains Mono', monospace;">
[7   8 ]
[15  16]</pre>
                                <p><strong>Key observations:</strong></p>
                                <ul>
                                    <li><strong>Size reduction:</strong> 4√ó4 ‚Üí 2√ó2 (75% reduction in values!)</li>
                                    <li><strong>Information preserved:</strong> We kept the strongest activations from each region</li>
                                    <li><strong>Translation robustness:</strong> If the feature was at position (0,0) or (0,1), we still detect it in the top-left region</li>
                                </ul>
                            </div>
                            
                            <div class="explanation-box">
                                <h5>üéØ Why Max Pooling vs Average Pooling?</h5>
                                <p><strong>Max Pooling (what we just did):</strong></p>
                                <ul>
                                    <li><strong>Keeps the strongest signal:</strong> "Was this feature detected strongly anywhere in this region?"</li>
                                    <li><strong>Better for:</strong> Detecting presence of features (edges, textures, objects)</li>
                                    <li><strong>Analogy:</strong> "Did anyone in this group see a cat?" ‚Üí If one person saw it clearly, the answer is yes!</li>
                                </ul>
                                
                                <p><strong>Average Pooling (alternative):</strong></p>
                                <ul>
                                    <li><strong>Takes the average:</strong> "What's the average strength of features in this region?"</li>
                                    <li><strong>Better for:</strong> Smoothing and reducing noise</li>
                                    <li><strong>Analogy:</strong> "What's the average opinion of this group?" ‚Üí Takes everyone's view into account</li>
                                </ul>
                                
                                <p><strong>In practice:</strong> Max pooling is more commonly used because it preserves the strongest activations, which are most informative for detecting features.</p>
                            </div>
                        </div>

                        <div class="code-box">
                            <h4>üíª Pooling Implementation</h4>
                            <pre><code>import numpy as np

def max_pooling(feature_map, pool_size=2, stride=2):
    """
    Max pooling operation
    
    Parameters:
    feature_map: Input feature map (H, W)
    pool_size: Size of pooling window
    stride: Step size
    """
    h, w = feature_map.shape
    out_h = (h - pool_size) // stride + 1
    out_w = (w - pool_size) // stride + 1
    
    output = np.zeros((out_h, out_w))
    
    for i in range(out_h):
        for j in range(out_w):
            region = feature_map[i*stride:i*stride+pool_size,
                                j*stride:j*stride+pool_size]
            output[i, j] = np.max(region)
    
    return output

# Example
feature_map = np.array([[1, 3, 2, 4],
                        [5, 7, 6, 8],
                        [9, 11, 10, 12],
                        [13, 15, 14, 16]])

pooled = max_pooling(feature_map, pool_size=2, stride=2)
print("Pooled result:\n", pooled)</code></pre>
                        </div>
                    </div>

                    <div id="architecture" class="content-section">
                        <h2>Complete CNN Architecture</h2>
                        
                        <div class="explanation-box">
                            <h3>üèóÔ∏è Typical CNN Structure</h3>
                            <p><strong>A typical CNN consists of alternating convolutional and pooling layers, followed by fully connected layers for classification.</strong></p>
                            
                            <p><strong>Standard Architecture:</strong></p>
                            <ol>
                                <li><strong>Convolutional Layers:</strong> Detect features (edges, textures, patterns)</li>
                                <li><strong>Pooling Layers:</strong> Reduce spatial dimensions</li>
                                <li><strong>More Conv+Pool:</strong> Learn higher-level features</li>
                                <li><strong>Flatten:</strong> Convert 2D to 1D</li>
                                <li><strong>Fully Connected:</strong> Final classification</li>
                            </ol>
                        </div>

                        <div class="example-box">
                            <h4>üìä Example: LeNet-5 Architecture</h4>
                            <p><strong>For 32√ó32 grayscale images:</strong></p>
                            <ul>
                                <li><strong>Input:</strong> 32√ó32√ó1</li>
                                <li><strong>Conv1:</strong> 6 filters, 5√ó5 ‚Üí 28√ó28√ó6</li>
                                <li><strong>Pool1:</strong> 2√ó2 max pool ‚Üí 14√ó14√ó6</li>
                                <li><strong>Conv2:</strong> 16 filters, 5√ó5 ‚Üí 10√ó10√ó16</li>
                                <li><strong>Pool2:</strong> 2√ó2 max pool ‚Üí 5√ó5√ó16</li>
                                <li><strong>Flatten:</strong> 400 neurons</li>
                                <li><strong>FC1:</strong> 120 neurons</li>
                                <li><strong>FC2:</strong> 84 neurons</li>
                                <li><strong>Output:</strong> 10 classes</li>
                            </ul>
                        </div>

                        <div class="code-box">
                            <h4>üíª Simple CNN Implementation</h4>
                            <pre><code>import numpy as np

class SimpleCNN:
    """Simple Convolutional Neural Network"""
    
    def __init__(self):
        # Convolutional layer: 1 input channel, 8 output channels, 3√ó3 kernel
        self.conv_weights = np.random.randn(8, 1, 3, 3) * 0.1
        self.conv_bias = np.zeros(8)
        
        # Fully connected layer
        self.fc_weights = np.random.randn(128, 8*26*26) * 0.1
        self.fc_bias = np.zeros(128)
        
        # Output layer
        self.output_weights = np.random.randn(10, 128) * 0.1
        self.output_bias = np.zeros(10)
    
    def relu(self, x):
        return np.maximum(0, x)
    
    def forward(self, x):
        """Forward pass through CNN"""
        # x shape: (batch, 1, 28, 28)
        batch_size = x.shape[0]
        
        # Convolution + ReLU
        conv_out = self.conv2d(x, self.conv_weights, self.conv_bias)
        conv_out = self.relu(conv_out)
        
        # Max pooling (2√ó2)
        pooled = self.max_pool2d(conv_out, 2)
        
        # Flatten
        flattened = pooled.reshape(batch_size, -1)
        
        # Fully connected + ReLU
        fc_out = np.dot(flattened, self.fc_weights.T) + self.fc_bias
        fc_out = self.relu(fc_out)
        
        # Output layer
        output = np.dot(fc_out, self.output_weights.T) + self.output_bias
        
        return output
    
    def conv2d(self, x, weights, bias):
        """2D Convolution"""
        # Simplified implementation
        # In practice, use optimized libraries
        pass
    
    def max_pool2d(self, x, pool_size):
        """2D Max Pooling"""
        # Simplified implementation
        pass

# Usage
cnn = SimpleCNN()
# Note: Full implementation requires optimized convolution operations</code></pre>
                        </div>
                    </div>

                    <div id="backprop" class="content-section">
                        <h2>Backpropagation in CNNs</h2>
                        
                        <div class="explanation-box">
                            <h3>üîÑ Gradient Flow Through Convolution</h3>
                            <p><strong>Backpropagation in CNNs follows the same principles as regular networks, but gradients must be properly distributed through convolution and pooling operations.</strong></p>
                        </div>

                        <div class="formula-box">
                            <h4>Convolution Gradient</h4>
                            <p><strong>For convolution layer:</strong></p>
                            
                            <div class="formula-display">
                                <strong>‚àÇL/‚àÇK = I * (‚àÇL/‚àÇO)</strong> (convolved with input)<br>
                                <strong>‚àÇL/‚àÇI = K * (‚àÇL/‚àÇO)</strong> (convolved with kernel, transposed)
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Key Insight:</h5>
                                <ul>
                                    <li>Gradient w.r.t. kernel: Convolve input with output gradient</li>
                                    <li>Gradient w.r.t. input: Convolve kernel (transposed) with output gradient</li>
                                    <li>This is the reverse of forward convolution</li>
                                </ul>
                            </div>
                        </div>

                        <div class="formula-box">
                            <h4>Pooling Gradient</h4>
                            <p><strong>For max pooling:</strong></p>
                            
                            <div class="formula-display">
                                <strong>Gradient flows only to the maximum value position</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Max Pooling Backprop:</h5>
                                <ul>
                                    <li>Gradient goes only to the position that had the maximum value</li>
                                    <li>Other positions receive zero gradient</li>
                                    <li>This is why max pooling is non-differentiable but works in practice</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div id="implementation" class="content-section">
                        <h2>Complete CNN Implementation</h2>
                        
                        <div class="code-box">
                            <h4>üíª Full CNN with PyTorch-style Structure</h4>
                            <pre><code>import numpy as np

class ConvLayer:
    """Convolutional Layer"""
    
    def __init__(self, in_channels, out_channels, kernel_size, stride=1, padding=0):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        
        # Initialize weights (He initialization)
        self.weights = np.random.randn(out_channels, in_channels, 
                                      kernel_size, kernel_size) * np.sqrt(2.0 / (in_channels * kernel_size * kernel_size))
        self.bias = np.zeros(out_channels)
    
    def forward(self, x):
        """Forward pass"""
        # x: (batch, in_channels, H, W)
        batch_size, _, h, w = x.shape
        
        # Calculate output dimensions
        out_h = (h + 2*self.padding - self.kernel_size) // self.stride + 1
        out_w = (w + 2*self.padding - self.kernel_size) // self.stride + 1
        
        # Add padding
        if self.padding > 0:
            x = np.pad(x, ((0,0), (0,0), (self.padding, self.padding), 
                          (self.padding, self.padding)), mode='constant')
        
        # Initialize output
        output = np.zeros((batch_size, self.out_channels, out_h, out_w))
        
        # Perform convolution for each output channel
        for b in range(batch_size):
            for oc in range(self.out_channels):
                for ic in range(self.in_channels):
                    for i in range(out_h):
                        for j in range(out_w):
                            region = x[b, ic, i*self.stride:i*self.stride+self.kernel_size,
                                      j*self.stride:j*self.stride+self.kernel_size]
                            output[b, oc, i, j] += np.sum(region * self.weights[oc, ic])
                output[b, oc] += self.bias[oc]
        
        return output

class MaxPoolLayer:
    """Max Pooling Layer"""
    
    def __init__(self, pool_size=2, stride=2):
        self.pool_size = pool_size
        self.stride = stride
    
    def forward(self, x):
        """Forward pass"""
        batch_size, channels, h, w = x.shape
        out_h = (h - self.pool_size) // self.stride + 1
        out_w = (w - self.pool_size) // self.stride + 1
        
        output = np.zeros((batch_size, channels, out_h, out_w))
        
        for b in range(batch_size):
            for c in range(channels):
                for i in range(out_h):
                    for j in range(out_w):
                        region = x[b, c, i*self.stride:i*self.stride+self.pool_size,
                                  j*self.stride:j*self.stride+self.pool_size]
                        output[b, c, i, j] = np.max(region)
        
        return output

# Example CNN
class SimpleCNN:
    def __init__(self):
        self.conv1 = ConvLayer(1, 8, 3, stride=1, padding=1)
        self.pool1 = MaxPoolLayer(2, stride=2)
        self.conv2 = ConvLayer(8, 16, 3, stride=1, padding=1)
        self.pool2 = MaxPoolLayer(2, stride=2)
    
    def forward(self, x):
        x = self.conv1.forward(x)
        x = np.maximum(0, x)  # ReLU
        x = self.pool1.forward(x)
        x = self.conv2.forward(x)
        x = np.maximum(0, x)  # ReLU
        x = self.pool2.forward(x)
        return x

# Usage
cnn = SimpleCNN()
# Input: batch of 1, 1 channel, 28√ó28 images
x = np.random.randn(1, 1, 28, 28)
output = cnn.forward(x)
print(f"Output shape: {output.shape}")  # (1, 16, 7, 7)</code></pre>
                        </div>
                    </div>

                    <div id="quiz" class="content-section">
                        <h2>Test Your Understanding</h2>
                        
                        <div class="quiz-container">
                            <div class="quiz-question">
                                <h3>Question 1: What is the main advantage of CNNs over fully connected networks for images?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) They are faster to train</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">B) Parameter sharing and spatial feature learning</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) They require less memory</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) They always give better accuracy</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 2: What does max pooling do?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) Increases image resolution</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">B) Reduces spatial dimensions and provides translation invariance</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Applies filters to images</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Adds noise to prevent overfitting</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 3: In a CNN, what do early convolutional layers typically learn?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Low-level features like edges and textures</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) High-level object recognition</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Classification decisions</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Only color information</div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </section>
    </main>

    <footer style="background: #f8f9fa; padding: 2rem 0; margin-top: 3rem; border-top: 2px solid #5B7553;">
        <div class="azbn-container" style="text-align: center;">
            <button onclick="scrollToSectionNav()" class="azbn-btn" style="margin: 0.5rem;">
                ‚Üë Back to Section Navigation
            </button>
            <div style="margin-top: 1.5rem;">
                <a href="/tutorials/neural-networks" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Back to Tutorial</a>
                <a href="/tutorials/neural-networks/chapter4" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Chapter 4</a>
                <a href="/tutorials/neural-networks/chapter6" class="azbn-btn" style="text-decoration: none; margin: 0.5rem;">Chapter 6: RNNs ‚Üí</a>
            </div>
        </div>
    </footer>
    
    <script src="{{ url_for('static', filename='js/tutorials/neural-networks/shared-tutorial.js') }}"></script>
    <script>
        function scrollToSectionNav() {
            const sectionNav = document.querySelector('.section-nav');
            if (sectionNav) {
                sectionNav.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        function checkAnswer(element, isCorrect) {
            element.parentNode.querySelectorAll('.quiz-option').forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
            });
            if (isCorrect) {
                element.classList.add('correct');
                element.textContent += ' ‚úì Correct!';
            } else {
                element.classList.add('incorrect');
                element.textContent += ' ‚úó Incorrect';
                const correctOption = Array.from(element.parentNode.querySelectorAll('.quiz-option'))
                    .find(opt => {
                        const onclick = opt.getAttribute('onclick') || '';
                        return onclick.includes('true');
                    });
                if (correctOption && !correctOption.classList.contains('incorrect')) {
                    correctOption.classList.add('correct');
                    correctOption.textContent += ' ‚úì Correct Answer';
                }
            }
        }
    </script>
</body>
</html>

