<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: Convolutional Neural Networks (CNNs) - Neural Networks Fundamentals</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/tutorials/neural-networks/neural-networks.css') }}">
</head>
<body>
    <header class="azbn-header">
        <nav class="azbn-nav">
            <div class="azbn-container">
                <a href="/tutorials/neural-networks" class="course-link">
                    <span>Neural Networks Fundamentals</span>
                </a>
                <div class="azbn-links">
                    <a href="/">Home</a>
                    <a href="/#about">About</a>
                    <a href="/tutorials/">Tutorials</a>
                    <a href="/#projects">Projects</a>
                    <a href="/contact">Contact</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        <div class="tutorial-header">
            <div class="azbn-container">
                <h1 class="chapter-title">Chapter 5: Convolutional Neural Networks (CNNs)</h1>
                <p class="chapter-subtitle">Specialized networks for image processing and spatial data</p>
                
                <div class="chapter-progress">
                    <div class="chapter-progress-fill" data-progress="62.5"></div>
                </div>
                
                <div class="chapter-navigation">
                    <a href="/tutorials/neural-networks/chapter1" class="chapter-nav-btn">Chapter 1</a>
                    <a href="/tutorials/neural-networks/chapter2" class="chapter-nav-btn">Chapter 2</a>
                    <a href="/tutorials/neural-networks/chapter3" class="chapter-nav-btn">Chapter 3</a>
                    <a href="/tutorials/neural-networks/chapter4" class="chapter-nav-btn">Chapter 4</a>
                    <a href="/tutorials/neural-networks/chapter5" class="chapter-nav-btn active">Chapter 5</a>
                    <a href="/tutorials/neural-networks/chapter6" class="chapter-nav-btn">Chapter 6</a>
                    <a href="/tutorials/neural-networks/chapter7" class="chapter-nav-btn">Chapter 7</a>
                    <a href="/tutorials/neural-networks/chapter8" class="chapter-nav-btn">Chapter 8</a>
                </div>
                
                <div class="section-progress">
                    <div class="section-progress-fill" data-progress="14.3"></div>
                </div>
                
                <div class="section-nav">
                    <button class="section-nav-btn azbn-btn active" data-section="overview">Overview</button>
                    <button class="section-nav-btn azbn-btn" data-section="convolution">Convolution Operation</button>
                    <button class="section-nav-btn azbn-btn" data-section="pooling">Pooling Layers</button>
                    <button class="section-nav-btn azbn-btn" data-section="architecture">CNN Architecture</button>
                    <button class="section-nav-btn azbn-btn" data-section="backprop">Backpropagation in CNNs</button>
                    <button class="section-nav-btn azbn-btn" data-section="implementation">Implementation</button>
                    <button class="section-nav-btn azbn-btn" data-section="quiz">Quiz</button>
                </div>
            </div>
        </div>

        <section class="azbn-section">
            <div class="azbn-container">
                <div class="learning-objectives-box">
                    <h2>Learning Objectives</h2>
                    <ul>
                        <li>Understand the convolution operation and its purpose</li>
                        <li>Master pooling layers and their role in CNNs</li>
                        <li>Learn complete CNN architecture</li>
                        <li>Understand backpropagation in convolutional layers</li>
                        <li>Implement a CNN from scratch</li>
                        <li>Recognize when to use CNNs vs MLPs</li>
                    </ul>
                </div>

                <main class="chapter-main-content">
                    <div id="overview" class="content-section active">
                        <h2>What are Convolutional Neural Networks?</h2>
                        
                        <div class="explanation-box">
                            <h3>üñºÔ∏è Specialized for Images</h3>
                            <p><strong>Convolutional Neural Networks (CNNs) are specialized neural networks designed for processing grid-like data such as images.</strong> Unlike fully connected networks, CNNs use convolution operations to automatically learn spatial hierarchies of features.</p>
                            
                            <p><strong>Key Advantages:</strong></p>
                            <ul>
                                <li><strong>Parameter Sharing:</strong> Same filter used across entire image (fewer parameters)</li>
                                <li><strong>Spatial Invariance:</strong> Can detect features regardless of position</li>
                                <li><strong>Translation Invariance:</strong> Recognizes objects even when shifted</li>
                                <li><strong>Hierarchical Features:</strong> Learns edges ‚Üí shapes ‚Üí objects</li>
                            </ul>
                        </div>

                        <div class="example-box">
                            <h4>üìö Why CNNs for Images?</h4>
                            <p><strong>Problem with MLPs for images:</strong></p>
                            <ul>
                                <li>28√ó28 image = 784 pixels = 784 input neurons</li>
                                <li>Fully connected to 100 hidden neurons = 78,400 weights!</li>
                                <li>No understanding of spatial relationships</li>
                                <li>Same pattern in different locations = different weights</li>
                            </ul>
                            
                            <p><strong>CNN Solution:</strong></p>
                            <ul>
                                <li>Uses small filters (e.g., 3√ó3) that scan the image</li>
                                <li>Same filter detects same pattern everywhere</li>
                                <li>Learns spatial hierarchies automatically</li>
                                <li>Much fewer parameters, better performance</li>
                            </ul>
                        </div>
                    </div>

                    <div id="convolution" class="content-section">
                        <h2>The Convolution Operation</h2>
                        
                        <div class="explanation-box">
                            <h3>üîç Sliding Window Filter</h3>
                            <p><strong>Convolution is a mathematical operation that applies a filter (kernel) to an input image by sliding it across the image and computing element-wise products.</strong></p>
                        </div>

                        <div class="formula-box">
                            <h4>Convolution Formula</h4>
                            <p>For a 2D convolution:</p>
                            
                            <div class="formula-display">
                                <strong>(I * K)[i, j] = Œ£‚Çò Œ£‚Çô I[i+m, j+n] √ó K[m, n]</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Notation:</h5>
                                <ul>
                                    <li><strong>I:</strong> Input image (matrix)</li>
                                    <li><strong>K:</strong> Kernel/filter (small matrix, e.g., 3√ó3)</li>
                                    <li><strong>*:</strong> Convolution operator</li>
                                    <li><strong>[i, j]:</strong> Output position</li>
                                    <li><strong>m, n:</strong> Kernel indices</li>
                                </ul>
                            </div>
                        </div>

                        <div class="example-box">
                            <h4>üî¢ Step-by-Step Example</h4>
                            <p><strong>Input Image (5√ó5):</strong></p>
                            <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px;">
[1  2  3  4  5]
[6  7  8  9  10]
[11 12 13 14 15]
[16 17 18 19 20]
[21 22 23 24 25]</pre>
                            
                            <p><strong>Filter (3√ó3):</strong></p>
                            <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px;">
[0  -1  0]
[-1  5  -1]
[0  -1  0]</pre>
                            
                            <p><strong>Convolution at position (1,1):</strong></p>
                            <p>Output[1,1] = 1√ó0 + 2√ó(-1) + 3√ó0 + 6√ó(-1) + 7√ó5 + 8√ó(-1) + 11√ó0 + 12√ó(-1) + 13√ó0</p>
                            <p>Output[1,1] = 0 - 2 + 0 - 6 + 35 - 8 + 0 - 12 + 0 = 7</p>
                            
                            <p><strong>This filter enhances edges!</strong></p>
                        </div>

                        <div class="code-box">
                            <h4>üíª Convolution Implementation</h4>
                            <pre><code>import numpy as np

def convolve2d(image, kernel, stride=1, padding=0):
    """
    2D Convolution operation
    
    Parameters:
    image: Input image (H, W)
    kernel: Filter/kernel (K_h, K_w)
    stride: Step size for sliding
    padding: Zero padding size
    """
    # Add padding
    if padding > 0:
        image = np.pad(image, padding, mode='constant')
    
    # Get dimensions
    img_h, img_w = image.shape
    kernel_h, kernel_w = kernel.shape
    
    # Calculate output dimensions
    out_h = (img_h - kernel_h) // stride + 1
    out_w = (img_w - kernel_w) // stride + 1
    
    # Initialize output
    output = np.zeros((out_h, out_w))
    
    # Perform convolution
    for i in range(0, out_h):
        for j in range(0, out_w):
            # Extract region
            region = image[i*stride:i*stride+kernel_h, 
                          j*stride:j*stride+kernel_w]
            # Element-wise multiplication and sum
            output[i, j] = np.sum(region * kernel)
    
    return output

# Example: Edge detection
image = np.array([[1, 2, 3, 4],
                  [5, 6, 7, 8],
                  [9, 10, 11, 12],
                  [13, 14, 15, 16]])

# Vertical edge detector
kernel = np.array([[-1, 0, 1],
                   [-1, 0, 1],
                   [-1, 0, 1]])

result = convolve2d(image, kernel)
print("Convolution result:\n", result)</code></pre>
                        </div>
                    </div>

                    <div id="pooling" class="content-section">
                        <h2>Pooling Layers</h2>
                        
                        <div class="explanation-box">
                            <h3>üìâ Downsampling Operation</h3>
                            <p><strong>Pooling layers reduce the spatial dimensions of feature maps, making the network more efficient and providing translation invariance.</strong> Common types include max pooling and average pooling.</p>
                        </div>

                        <div class="formula-box">
                            <h4>Max Pooling</h4>
                            <p><strong>Takes the maximum value in each pooling window:</strong></p>
                            
                            <div class="formula-display">
                                <strong>Output[i, j] = max(Input[i√ós : i√ós+p, j√ós : j√ós+p])</strong>
                            </div>
                            
                            <p>Where <strong>s</strong> is stride and <strong>p</strong> is pool size</p>
                            
                            <div class="formula-explanation">
                                <h5>Why Max Pooling?</h5>
                                <ul>
                                    <li><strong>Reduces computation:</strong> Smaller feature maps</li>
                                    <li><strong>Translation invariance:</strong> Detects features regardless of exact position</li>
                                    <li><strong>Preserves strongest activations:</strong> Keeps most important features</li>
                                </ul>
                            </div>
                        </div>

                        <div class="example-box">
                            <h4>üî¢ Max Pooling Example</h4>
                            <p><strong>Input (4√ó4):</strong></p>
                            <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px;">
[1  3  2  4]
[5  7  6  8]
[9  11 10 12]
[13 15 14 16]</pre>
                            
                            <p><strong>Max Pooling (2√ó2, stride=2):</strong></p>
                            <pre style="background: #f5f5f5; padding: 1rem; border-radius: 5px;">
[7  8]
[15 16]</pre>
                            
                            <p><strong>Explanation:</strong></p>
                            <ul>
                                <li>Top-left: max(1,3,5,7) = 7</li>
                                <li>Top-right: max(2,4,6,8) = 8</li>
                                <li>Bottom-left: max(9,11,13,15) = 15</li>
                                <li>Bottom-right: max(10,12,14,16) = 16</li>
                            </ul>
                        </div>

                        <div class="code-box">
                            <h4>üíª Pooling Implementation</h4>
                            <pre><code>import numpy as np

def max_pooling(feature_map, pool_size=2, stride=2):
    """
    Max pooling operation
    
    Parameters:
    feature_map: Input feature map (H, W)
    pool_size: Size of pooling window
    stride: Step size
    """
    h, w = feature_map.shape
    out_h = (h - pool_size) // stride + 1
    out_w = (w - pool_size) // stride + 1
    
    output = np.zeros((out_h, out_w))
    
    for i in range(out_h):
        for j in range(out_w):
            region = feature_map[i*stride:i*stride+pool_size,
                                j*stride:j*stride+pool_size]
            output[i, j] = np.max(region)
    
    return output

# Example
feature_map = np.array([[1, 3, 2, 4],
                        [5, 7, 6, 8],
                        [9, 11, 10, 12],
                        [13, 15, 14, 16]])

pooled = max_pooling(feature_map, pool_size=2, stride=2)
print("Pooled result:\n", pooled)</code></pre>
                        </div>
                    </div>

                    <div id="architecture" class="content-section">
                        <h2>Complete CNN Architecture</h2>
                        
                        <div class="explanation-box">
                            <h3>üèóÔ∏è Typical CNN Structure</h3>
                            <p><strong>A typical CNN consists of alternating convolutional and pooling layers, followed by fully connected layers for classification.</strong></p>
                            
                            <p><strong>Standard Architecture:</strong></p>
                            <ol>
                                <li><strong>Convolutional Layers:</strong> Detect features (edges, textures, patterns)</li>
                                <li><strong>Pooling Layers:</strong> Reduce spatial dimensions</li>
                                <li><strong>More Conv+Pool:</strong> Learn higher-level features</li>
                                <li><strong>Flatten:</strong> Convert 2D to 1D</li>
                                <li><strong>Fully Connected:</strong> Final classification</li>
                            </ol>
                        </div>

                        <div class="example-box">
                            <h4>üìä Example: LeNet-5 Architecture</h4>
                            <p><strong>For 32√ó32 grayscale images:</strong></p>
                            <ul>
                                <li><strong>Input:</strong> 32√ó32√ó1</li>
                                <li><strong>Conv1:</strong> 6 filters, 5√ó5 ‚Üí 28√ó28√ó6</li>
                                <li><strong>Pool1:</strong> 2√ó2 max pool ‚Üí 14√ó14√ó6</li>
                                <li><strong>Conv2:</strong> 16 filters, 5√ó5 ‚Üí 10√ó10√ó16</li>
                                <li><strong>Pool2:</strong> 2√ó2 max pool ‚Üí 5√ó5√ó16</li>
                                <li><strong>Flatten:</strong> 400 neurons</li>
                                <li><strong>FC1:</strong> 120 neurons</li>
                                <li><strong>FC2:</strong> 84 neurons</li>
                                <li><strong>Output:</strong> 10 classes</li>
                            </ul>
                        </div>

                        <div class="code-box">
                            <h4>üíª Simple CNN Implementation</h4>
                            <pre><code>import numpy as np

class SimpleCNN:
    """Simple Convolutional Neural Network"""
    
    def __init__(self):
        # Convolutional layer: 1 input channel, 8 output channels, 3√ó3 kernel
        self.conv_weights = np.random.randn(8, 1, 3, 3) * 0.1
        self.conv_bias = np.zeros(8)
        
        # Fully connected layer
        self.fc_weights = np.random.randn(128, 8*26*26) * 0.1
        self.fc_bias = np.zeros(128)
        
        # Output layer
        self.output_weights = np.random.randn(10, 128) * 0.1
        self.output_bias = np.zeros(10)
    
    def relu(self, x):
        return np.maximum(0, x)
    
    def forward(self, x):
        """Forward pass through CNN"""
        # x shape: (batch, 1, 28, 28)
        batch_size = x.shape[0]
        
        # Convolution + ReLU
        conv_out = self.conv2d(x, self.conv_weights, self.conv_bias)
        conv_out = self.relu(conv_out)
        
        # Max pooling (2√ó2)
        pooled = self.max_pool2d(conv_out, 2)
        
        # Flatten
        flattened = pooled.reshape(batch_size, -1)
        
        # Fully connected + ReLU
        fc_out = np.dot(flattened, self.fc_weights.T) + self.fc_bias
        fc_out = self.relu(fc_out)
        
        # Output layer
        output = np.dot(fc_out, self.output_weights.T) + self.output_bias
        
        return output
    
    def conv2d(self, x, weights, bias):
        """2D Convolution"""
        # Simplified implementation
        # In practice, use optimized libraries
        pass
    
    def max_pool2d(self, x, pool_size):
        """2D Max Pooling"""
        # Simplified implementation
        pass

# Usage
cnn = SimpleCNN()
# Note: Full implementation requires optimized convolution operations</code></pre>
                        </div>
                    </div>

                    <div id="backprop" class="content-section">
                        <h2>Backpropagation in CNNs</h2>
                        
                        <div class="explanation-box">
                            <h3>üîÑ Gradient Flow Through Convolution</h3>
                            <p><strong>Backpropagation in CNNs follows the same principles as regular networks, but gradients must be properly distributed through convolution and pooling operations.</strong></p>
                        </div>

                        <div class="formula-box">
                            <h4>Convolution Gradient</h4>
                            <p><strong>For convolution layer:</strong></p>
                            
                            <div class="formula-display">
                                <strong>‚àÇL/‚àÇK = I * (‚àÇL/‚àÇO)</strong> (convolved with input)<br>
                                <strong>‚àÇL/‚àÇI = K * (‚àÇL/‚àÇO)</strong> (convolved with kernel, transposed)
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Key Insight:</h5>
                                <ul>
                                    <li>Gradient w.r.t. kernel: Convolve input with output gradient</li>
                                    <li>Gradient w.r.t. input: Convolve kernel (transposed) with output gradient</li>
                                    <li>This is the reverse of forward convolution</li>
                                </ul>
                            </div>
                        </div>

                        <div class="formula-box">
                            <h4>Pooling Gradient</h4>
                            <p><strong>For max pooling:</strong></p>
                            
                            <div class="formula-display">
                                <strong>Gradient flows only to the maximum value position</strong>
                            </div>
                            
                            <div class="formula-explanation">
                                <h5>Max Pooling Backprop:</h5>
                                <ul>
                                    <li>Gradient goes only to the position that had the maximum value</li>
                                    <li>Other positions receive zero gradient</li>
                                    <li>This is why max pooling is non-differentiable but works in practice</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div id="implementation" class="content-section">
                        <h2>Complete CNN Implementation</h2>
                        
                        <div class="code-box">
                            <h4>üíª Full CNN with PyTorch-style Structure</h4>
                            <pre><code>import numpy as np

class ConvLayer:
    """Convolutional Layer"""
    
    def __init__(self, in_channels, out_channels, kernel_size, stride=1, padding=0):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        
        # Initialize weights (He initialization)
        self.weights = np.random.randn(out_channels, in_channels, 
                                      kernel_size, kernel_size) * np.sqrt(2.0 / (in_channels * kernel_size * kernel_size))
        self.bias = np.zeros(out_channels)
    
    def forward(self, x):
        """Forward pass"""
        # x: (batch, in_channels, H, W)
        batch_size, _, h, w = x.shape
        
        # Calculate output dimensions
        out_h = (h + 2*self.padding - self.kernel_size) // self.stride + 1
        out_w = (w + 2*self.padding - self.kernel_size) // self.stride + 1
        
        # Add padding
        if self.padding > 0:
            x = np.pad(x, ((0,0), (0,0), (self.padding, self.padding), 
                          (self.padding, self.padding)), mode='constant')
        
        # Initialize output
        output = np.zeros((batch_size, self.out_channels, out_h, out_w))
        
        # Perform convolution for each output channel
        for b in range(batch_size):
            for oc in range(self.out_channels):
                for ic in range(self.in_channels):
                    for i in range(out_h):
                        for j in range(out_w):
                            region = x[b, ic, i*self.stride:i*self.stride+self.kernel_size,
                                      j*self.stride:j*self.stride+self.kernel_size]
                            output[b, oc, i, j] += np.sum(region * self.weights[oc, ic])
                output[b, oc] += self.bias[oc]
        
        return output

class MaxPoolLayer:
    """Max Pooling Layer"""
    
    def __init__(self, pool_size=2, stride=2):
        self.pool_size = pool_size
        self.stride = stride
    
    def forward(self, x):
        """Forward pass"""
        batch_size, channels, h, w = x.shape
        out_h = (h - self.pool_size) // self.stride + 1
        out_w = (w - self.pool_size) // self.stride + 1
        
        output = np.zeros((batch_size, channels, out_h, out_w))
        
        for b in range(batch_size):
            for c in range(channels):
                for i in range(out_h):
                    for j in range(out_w):
                        region = x[b, c, i*self.stride:i*self.stride+self.pool_size,
                                  j*self.stride:j*self.stride+self.pool_size]
                        output[b, c, i, j] = np.max(region)
        
        return output

# Example CNN
class SimpleCNN:
    def __init__(self):
        self.conv1 = ConvLayer(1, 8, 3, stride=1, padding=1)
        self.pool1 = MaxPoolLayer(2, stride=2)
        self.conv2 = ConvLayer(8, 16, 3, stride=1, padding=1)
        self.pool2 = MaxPoolLayer(2, stride=2)
    
    def forward(self, x):
        x = self.conv1.forward(x)
        x = np.maximum(0, x)  # ReLU
        x = self.pool1.forward(x)
        x = self.conv2.forward(x)
        x = np.maximum(0, x)  # ReLU
        x = self.pool2.forward(x)
        return x

# Usage
cnn = SimpleCNN()
# Input: batch of 1, 1 channel, 28√ó28 images
x = np.random.randn(1, 1, 28, 28)
output = cnn.forward(x)
print(f"Output shape: {output.shape}")  # (1, 16, 7, 7)</code></pre>
                        </div>
                    </div>

                    <div id="quiz" class="content-section">
                        <h2>Test Your Understanding</h2>
                        
                        <div class="quiz-container">
                            <div class="quiz-question">
                                <h3>Question 1: What is the main advantage of CNNs over fully connected networks for images?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) They are faster to train</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">B) Parameter sharing and spatial feature learning</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) They require less memory</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) They always give better accuracy</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 2: What does max pooling do?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">A) Increases image resolution</div>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">B) Reduces spatial dimensions and provides translation invariance</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Applies filters to images</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Adds noise to prevent overfitting</div>
                            </div>
                            
                            <div class="quiz-question" style="margin-top: 2rem;">
                                <h3>Question 3: In a CNN, what do early convolutional layers typically learn?</h3>
                                <div class="quiz-option" onclick="checkAnswer(this, true)">A) Low-level features like edges and textures</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">B) High-level object recognition</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">C) Classification decisions</div>
                                <div class="quiz-option" onclick="checkAnswer(this, false)">D) Only color information</div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </section>
    </main>

    <footer style="background: #f8f9fa; padding: 2rem 0; margin-top: 3rem; border-top: 2px solid #5B7553;">
        <div class="azbn-container" style="text-align: center;">
            <button onclick="scrollToSectionNav()" class="azbn-btn" style="margin: 0.5rem;">
                ‚Üë Back to Section Navigation
            </button>
            <div style="margin-top: 1.5rem;">
                <a href="/tutorials/neural-networks" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Back to Tutorial</a>
                <a href="/tutorials/neural-networks/chapter4" class="azbn-btn azbn-secondary" style="text-decoration: none; margin: 0.5rem;">‚Üê Chapter 4</a>
                <a href="/tutorials/neural-networks/chapter6" class="azbn-btn" style="text-decoration: none; margin: 0.5rem;">Chapter 6: RNNs ‚Üí</a>
            </div>
        </div>
    </footer>
    
    <script src="{{ url_for('static', filename='js/tutorials/neural-networks/shared-tutorial.js') }}"></script>
    <script>
        function scrollToSectionNav() {
            const sectionNav = document.querySelector('.section-nav');
            if (sectionNav) {
                sectionNav.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        function checkAnswer(element, isCorrect) {
            element.parentNode.querySelectorAll('.quiz-option').forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
            });
            if (isCorrect) {
                element.classList.add('correct');
                element.textContent += ' ‚úì Correct!';
            } else {
                element.classList.add('incorrect');
                element.textContent += ' ‚úó Incorrect';
                const correctOption = Array.from(element.parentNode.querySelectorAll('.quiz-option'))
                    .find(opt => {
                        const onclick = opt.getAttribute('onclick') || '';
                        return onclick.includes('true');
                    });
                if (correctOption && !correctOption.classList.contains('incorrect')) {
                    correctOption.classList.add('correct');
                    correctOption.textContent += ' ‚úì Correct Answer';
                }
            }
        }
    </script>
</body>
</html>

